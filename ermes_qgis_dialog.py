# -*- coding: utf-8 -*-
"""
/***************************************************************************
  ErmesQGISDialog
                                 A QGIS plugin
 Integration of ERMES model in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gaetano Chiriaco - Links Foundation
        email                : gaetano.chiriaco@linksfoundation.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsRasterLayer,
    QgsProject,
    QgsMessageLog,
    Qgis,
    QgsMapLayerProxyModel,
    QgsGeometry,
    QgsVectorLayer,
)
from qgis.PyQt.QtCore import QObject, QThread, pyqtSignal, QDateTime
import ssl
import pika
import json
from datetime import datetime

from shapely.wkt import loads as wkt_loads
from shapely.geometry import mapping
from shapely.ops import unary_union
import uuid


class RabbitMQWorker(QObject):

    finished = pyqtSignal()
    layer_ready = pyqtSignal(str)
    status_updated = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(
        self,
        ca_file: str,
        cert_file: str,
        key_file: str,
        user_id: str,
        exchange: str,
        host: str = "localhost",
        port: int = 5672,
        vhost: str = "/",
    ):
        super().__init__()
        self.ca_file = ca_file
        self.cert_file = cert_file
        self.key_file = key_file
        self.host = host
        self.port = port
        self.vhost = vhost
        self.exchange = exchange
        self.connection = None
        self.channel = None
        self.queue_name = f"qgis_user_{user_id}"
        self.user_id = user_id
        self.is_running = True
        self.create_connection()

    def create_connection(self):
        credentials = pika.credentials.ExternalCredentials()
        ssl_options = self._get_tls_parameters()

        connection_parameters = pika.ConnectionParameters(
            credentials=credentials,
            host=self.host,
            port=self.port,
            ssl_options=ssl_options,
            virtual_host=self.vhost,
        )

        self.connection = pika.BlockingConnection(connection_parameters)
        self.channel = self.connection.channel()

    def _get_tls_parameters(self):
        context = ssl.create_default_context(cafile=self.ca_file)
        context.verify_mode = ssl.CERT_REQUIRED
        context.load_cert_chain(
            certfile=self.cert_file,
            keyfile=self.key_file,
        )
        return pika.SSLOptions(context, server_hostname=self.host)

    def _check_connection(self):
        if (
            self.connection is None
            or self.connection.is_closed
            or self.channel.is_closed
        ):
            self.create_connection()

    def _download_resource(self, url, local_path):
        self.status_updated.emit(f"Downloading {url} to {local_path}")
        return local_path

    def run(self):
        try:
            self.status_updated.emit("Worker: Connecting to RabbitMQ")
            self._check_connection()
            self.channel.queue_declare(queue=self.queue_name, durable=True)
            self.status_updated.emit(f"Created queue {self.queue_name}")

            self.channel.queue_bind(
                exchange=self.exchange,
                queue=self.queue_name,
                routing_key=f"test.status.orch.{self.user_id}.#",
            )
            self.status_updated.emit(
                f"Worker: Listening on queue '{self.queue_name}'..."
            )
            self.channel.basic_consume(
                queue=self.queue_name,
                on_message_callback=self.message_callback,
                auto_ack=True,
            )

            self.channel.start_consuming()
        except Exception as e:
            self.error.emit(f"Worker Error: {e}")
        finally:
            self.finished.emit()

    def message_callback(self, ch, method, properties, body):
        """Called when a message is received"""
        try:
            self.status_updated.emit(f"Worker: Received message: {body}")
            message = json.loads(body)

            if message.get("type") == "end" and "url" in message:
                url = message["url"]
                self.status_updated.emit(
                    f"Worker: 'end' message received. Downloading from {url}"
                )
                local_path = self._download_resource(url, "test_path")
                self.layer_ready.emit(local_path)
        except Exception as e:
            self.error.emit(f"Download Error: {e}")

    def stop(self):
        """Stops the consumer."""
        self.status_updated.emit("Worker: Stopping...")
        if self.channel and self.channel.is_open:
            self.channel.stop_consuming()


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")
)


class ErmesQGISDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(ErmesQGISDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.mcb_polygonLayer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dte_startDate.setDateTime(QDateTime.currentDateTime())
        self.dte_endDate.setDateTime(QDateTime.currentDateTime())

        self.thread = None
        self.worker = None
        plugin_dir = os.path.dirname(__file__)
        self.ca_file = os.path.join(plugin_dir, "certs/ca_certificate.pem")
        self.cert_file = os.path.join(plugin_dir, "certs/client_links_certificate.pem")
        self.key_file = os.path.join(plugin_dir, "certs/client_links_key.pem")
        self.host = "bus.gaia-project.cloud"
        self.port = "5671"
        self.vhost = "gaia-dev"
        self.exchange = "gaia.test"
        self.pipeline_map = {
            "Burned area delineation": "fire_burned_area_delineation",
            "Burn Severity estimation": "fire_burned_area_severity_estimation",
            "Sentinel-2 image": "fire_satellite_image_sentinel_2",
        }

        # Connect UI signals to methods
        self.btn_startListening.clicked.connect(self.start_listening)
        self.btn_sendRequest.clicked.connect(self.send_request)

        # Set default values for convenience
        self.le_userID.setText("user123")

    def send_request(self):
        """Sends a message to the RabbitMQ exchange."""
        selected_layer = self.mcb_polygonLayer.currentLayer()
        pipeline_text = self.cmb_pipeline.currentText()
        start_dt = self.dte_startDate.dateTime().toPyDateTime()
        end_dt = self.dte_endDate.dateTime().toPyDateTime()
        user_id = self.le_userID.text()  # This will be the routing key

        if not isinstance(selected_layer, QgsVectorLayer):
            self.update_status("Error: Please select a valid polygon layer.", "error")
            return

        all_geoms = [feature.geometry() for feature in selected_layer.getFeatures()]
        if not all_geoms:
            self.update_status("Error: The selected layer has no features.", "error")
            return

        unified_qgs_geom = QgsGeometry.unaryUnion(all_geoms)
        if unified_qgs_geom.isEmpty():
            self.update_status(
                "Error: Could not create a valid geometry from the layer.", "error"
            )
            return

        wkt_geometry = unified_qgs_geom.asWkt()
        shapely_polygon = wkt_loads(wkt_geometry)

        if not all([user_id, selected_layer]):
            self.update_status("Error: All fields are required to send.", "error")
            return

        try:
            self.update_status("Sending message...")
            credentials = pika.credentials.ExternalCredentials()
            context = ssl.create_default_context(cafile=self.ca_file)
            context.verify_mode = ssl.CERT_REQUIRED
            context.load_cert_chain(
                certfile=self.cert_file,
                keyfile=self.key_file,
            )
            ssl_options = pika.SSLOptions(context, server_hostname=self.host)
            connection_parameters = pika.ConnectionParameters(
                credentials=credentials,
                host=self.host,
                port=self.port,
                ssl_options=ssl_options,
                virtual_host=self.vhost,
            )

            connection = pika.BlockingConnection(connection_parameters)
            channel = connection.channel()
            channel.queue_declare(queue=f"qgis_user_{user_id}", durable=True)
            self.update_status(f"Created queue qgis_user_{user_id}")

            channel.queue_bind(
                exchange=self.exchange,
                queue=f"qgis_user_{user_id}",
                routing_key=f"test.request.{user_id}",
            )

            # The message is a simple string here, but JSON is better
            message_dict = {
                "datatype_id": self.pipeline_map[pipeline_text],
                "geometry": mapping(
                    shapely_polygon
                ),  # Send the geometry as a WKT string
                "start": start_dt.isoformat(),
                "end": end_dt.isoformat(),
            }

            channel.basic_publish(
                exchange=self.exchange,
                routing_key=f"test.request.{user_id}",  # Route the message specifically to this user's queue
                body=json.dumps(message_dict),
                properties=pika.BasicProperties(
                    delivery_mode=2,
                    message_id=f"{user_id}.{str(uuid.uuid4())}",
                    user_id="links",
                ),  # make message persistent
            )
            connection.close()
            self.update_status(f"Message sent to user '{user_id}'.", "info")
        except Exception as e:
            self.update_status(f"Error sending message: {e}", "error")

    def start_listening(self):
        """Set up the worker and thread to start listening for messages."""
        if self.thread is not None and self.thread.isRunning():
            self.update_status("Already listening.", "warning")
            return

        user_id = self.le_userID.text()

        if not all([user_id]):
            self.update_status("Error: Connection fields are required.", "error")
            return

        # 1. Create a QThread
        self.thread = QThread()
        # 2. Create a worker
        self.worker = RabbitMQWorker(
            ca_file=self.ca_file,
            cert_file=self.cert_file,
            key_file=self.key_file,
            user_id=user_id,
            exchange=self.exchange,
            host=self.host,
            port=self.port,
            vhost=self.vhost,
        )
        # 3. Move worker to the thread
        self.worker.moveToThread(self.thread)

        # 4. Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        self.worker.layer_ready.connect(self.load_layer)
        self.worker.status_updated.connect(self.update_status)
        self.worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # 5. Start the thread
        self.thread.start()

        self.btn_startListening.setEnabled(False)
        self.update_status("Listener started. Waiting for messages...", "info")

    def load_layer(self, file_path, layer_name):
        """Loads the downloaded file into QGIS. This runs on the main thread."""
        self.update_status(f"Loading layer: {layer_name}", "info")

        # Note: This is a simple example. For ZIP files, you would need to
        # unzip the file first and then find the appropriate .tif or .shp file inside.
        if file_path.lower().endswith((".tif", ".tiff")):
            layer = QgsRasterLayer(file_path, layer_name)
            if not layer.isValid():
                self.update_status(
                    f"Error: Failed to load raster layer {layer_name}", "error"
                )
                return
            QgsProject.instance().addMapLayer(layer)
            self.update_status(f"Successfully loaded {layer_name}", "success")
        else:
            self.update_status(
                f"Warning: File type not supported for auto-loading: {file_path}",
                "warning",
            )

    def update_status(self, message, level="info"):
        """Updates the status label and logs to QGIS log."""
        self.lbl_status.setText(message)
        log_level = Qgis.Info
        if level == "error":
            log_level = Qgis.Critical
        elif level == "warning":
            log_level = Qgis.Warning
        elif level == "success":
            log_level = Qgis.Success

        QgsMessageLog.logMessage(message, "RabbitMQ_Listener", level=log_level)

    def closeEvent(self, event):
        """Ensure the thread is stopped when the dialog is closed."""
        self.update_status("Closing dialog, stopping listener...")
        if self.thread and self.thread.isRunning():
            self.worker.stop()
            self.thread.quit()
            self.thread.wait()  # Wait for the thread to finish
        event.accept()
