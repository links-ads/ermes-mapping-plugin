# -*- coding: utf-8 -*-
"""
/***************************************************************************
  ErmesQGISDialog
                                 A QGIS plugin
 Integration of ERMES model in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gaetano Chiriaco - Links Foundation
        email                : gaetano.chiriaco@linksfoundation.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import json
import os
import pika
import requests
from shapely.wkt import loads as wkt_loads
from shapely.geometry import mapping
import shutil
import ssl
import tempfile
import uuid
import zipfile

from qgis.core import (
    QgsRasterLayer,
    QgsProject,
    QgsMessageLog,
    Qgis,
    QgsGeometry,
    QgsVectorLayer,
    QgsApplication,
)
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from qgis.PyQt.QtCore import QObject, QThread, pyqtSignal, QDateTime
from datetime import datetime


def parse_date(date: str) -> str:
    """If a date string is set it parses it into a format YYYY-MM-DD. In case parsing fails None is returned.

    :param date: A string describing a date
    :return: A string in a format YYYY-MM-DD, an empty string, or None
    """
    if date == "":
        return date
    try:
        return datetime.fromisoformat(date).isoformat()
    except ValueError:
        return None


class MainWorker(QObject):

    # FLAGS
    # Signals when Worker is finished, triggers clean-up and closes thread
    finished = pyqtSignal()
    # Signals when the layer is ready to be downloaded on Datalake
    layer_ready = pyqtSignal(str)
    # Used for INFO logging
    status_updated = pyqtSignal(str)
    # Used for ERROR logging
    error = pyqtSignal(str)

    def __init__(
        self,
        broker_ca_file: str,
        broker_cert_file: str,
        broker_key_file: str,
        user_id: str,
        exchange: str,
        host: str = "localhost",
        port: int = 5672,
        vhost: str = "/",
        datalake_oauth_user: str = "",
        datalake_oauth_password: str = "",
        datalake_oauth_app_id: str = "",
        datalake_oauth_api_key: str = "",
        datalake_auth_url: str = "",
    ):
        super().__init__()
        self.ca_file = broker_ca_file
        self.cert_file = broker_cert_file
        self.key_file = broker_key_file
        self.host = host
        self.port = port
        self.vhost = vhost
        self.exchange = exchange
        self.connection = None
        self.channel = None
        self.queue_name = f"qgis_user_{user_id}"
        self.user_id = user_id
        self.is_running = True
        self.oauth_user = datalake_oauth_user
        self.oauth_password = datalake_oauth_password
        self.oauth_app_id = datalake_oauth_app_id
        self.oauth_api_key = datalake_oauth_api_key
        self.auth_url = datalake_auth_url

        self.create_connection()

    def create_connection(self):
        """
        Establishes a connection to the RabbitMQ message broker
        """
        credentials = pika.credentials.ExternalCredentials()
        ssl_options = self._get_tls_parameters()

        connection_parameters = pika.ConnectionParameters(
            credentials=credentials,
            host=self.host,
            port=self.port,
            ssl_options=ssl_options,
            virtual_host=self.vhost,
        )

        self.connection = pika.BlockingConnection(connection_parameters)
        self.channel = self.connection.channel()

    def _get_tls_parameters(self):
        """
        Gets the TLS parameters for the RabbitMQ connection

        :returns: A pika.SSLOptions object.
        """
        context = ssl.create_default_context(cafile=self.ca_file)
        context.verify_mode = ssl.CERT_REQUIRED
        context.load_cert_chain(
            certfile=self.cert_file,
            keyfile=self.key_file,
        )
        return pika.SSLOptions(context, server_hostname=self.host)

    def _check_connection(self):
        """
        Checks if the connection is valid and if not, creates a new connection.
        """
        if (
            self.connection is None
            or self.connection.is_closed
            or self.channel.is_closed
        ):
            self.create_connection()

    def _get_access(self):
        """
        Retrieves access tokens by authenticating with the OAuth service of DataLake

        :returns: A dictionary containing the Authorization header with the Bearer token.
        :raises HTTPError: If the authentication request fails.
        """

        data = {
            "loginId": self.oauth_user,
            "password": self.oauth_password,
            "applicationId": self.oauth_app_id,
            "noJwt": "false",
        }
        headers = {
            "Authorization": self.oauth_api_key,
            "Content-Type": "application/json",
        }
        response = requests.post(self.auth_url, json=data, headers=headers)
        response.raise_for_status()
        self.access_token = response.json()["token"]
        self.refresh_token = response.json()["refreshToken"]
        return {"Authorization": f"Bearer {self.access_token}"}

    def _download_resource(self, url: str):
        """
        Downloads a resource from the given DataLake URL and saves it to a temporary cache path.

        :param url: The URL of the resource to be downloaded.
        :return: The local cache path where the downloaded resource is saved.
        :raises HTTPError: If the HTTP request to the URL fails.
        """

        self.status_updated.emit(f"Downloading from {url}")
        header = self._get_access()
        cache_path = f"./tmp/{uuid.uuid4()}/{url.split('/')[-1]}"
        os.makedirs(os.path.dirname(cache_path), exist_ok=True)

        with requests.get(url, headers=header, stream=True) as response:
            response.raise_for_status()
            with open(cache_path, "wb") as f:
                # Iterate over the response data in chunks
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:  # Filter out keep-alive chunks
                        f.write(chunk)

        return cache_path

    def run(self):
        """
        Start consuming messages from the RabbitMQ queue.

        This method will run indefinitely until an exception is raised or the plugin is closed.
        When the method finishes, the `finished` signal will be emitted.

        :raises Exception: If an exception occurs while consuming messages.
        """
        try:
            self.status_updated.emit("Worker: Connecting to RabbitMQ")
            self._check_connection()
            self.channel.queue_declare(queue=self.queue_name, auto_delete=True)
            self.status_updated.emit(f"Created queue {self.queue_name}")

            self.channel.queue_bind(
                exchange=self.exchange,
                queue=self.queue_name,
                routing_key=f"test.status.orch.*.*.{self.user_id}.#",
            )
            self.status_updated.emit(
                f"Worker: Listening on queue '{self.queue_name}'..."
            )
            self.channel.basic_consume(
                queue=self.queue_name,
                on_message_callback=self.message_callback,
                auto_ack=True,
            )

            self.channel.start_consuming()
        except Exception as e:
            self.error.emit(f"Worker Error: {e}")
        finally:
            self.finished.emit()

    def message_callback(self, ch, method, properties, body):
        """
        Callback function to process incoming messages from RabbitMQ.

        This function is called when a message is received from the RabbitMQ queue.
        It will attempt to parse the message as JSON and extract the URL of the resource
        to download. If the message is of type "end" and contains a "urls" field, it will
        attempt to download the resource from the first URL in the list and emit the
        `layer_ready` signal with the local path of the downloaded file.

        :param ch: Pika channel object
        :param method: Pika method object
        :param properties: Pika properties object
        :param body: Message body as a bytes object
        :raises Exception: If an exception occurs while processing the message
        """
        try:
            self.status_updated.emit(f"Worker: Received message: {body}")
            message = json.loads(body)

            if message.get("type") == "end" and "urls" in message:
                url = message["urls"]
                self.status_updated.emit(
                    f"Worker: 'ends' message received. Downloading from {url[0]}"
                )
                local_path = self._download_resource(url[0])
                self.status_updated.emit(f"Worker: Downloaded to {local_path}")
                self.layer_ready.emit(local_path)
        except Exception as e:
            self.error.emit(f"Download Error: {e}")

    def stop(self):
        """Stops the consumer. Called when the plugin is closed."""
        self.status_updated.emit("Worker: Stopping...")
        if self.channel and self.channel.is_open:
            self.channel.stop_consuming()


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")
)


class ErmesQGISDialog(QtWidgets.QDockWidget, FORM_CLASS):
    def __init__(self, parent=None):

        super(ErmesQGISDialog, self).__init__(parent)
        self.setupUi(self)

        # Setup for temporary directory management
        self.temp_dirs_to_clean = []
        QgsApplication.instance().aboutToQuit.connect(self.cleanup_temp_dirs)

        # Worker utils
        self.thread = None
        self.worker = None

        # Setup for RabbitMQ
        plugin_dir = os.path.dirname(__file__)
        self.ca_file = os.path.join(plugin_dir, "certs/ca_certificate.pem")
        self.cert_file = os.path.join(plugin_dir, "certs/client_links_certificate.pem")
        self.key_file = os.path.join(plugin_dir, "certs/client_links_key.pem")
        self.config_path = os.path.join(plugin_dir, "certs/config.json")
        self.config = json.load(open(self.config_path))
        self.active_time = None
        self.host = self.config["broker_host"]
        self.port = self.config["broker_port"]
        self.vhost = self.config["broker_vhost"]
        self.exchange = self.config["broker_exchange"]
        self.datalake_oauth_user = self.config["datalake_oauth_user"]
        self.datalake_oauth_password = self.config["datalake_oauth_password"]
        self.datalake_oauth_app_id = self.config["datalake_oauth_app_id"]
        self.datalake_oauth_api_key = self.config["datalake_oauth_api_key"]
        self.datalake_oauth_url = self.config["datalake_oauth_url"]

        # Available pipelines
        self.pipeline_map = {
            "Burned area delineation": "fire_burned_area_delineation",
            "Burn Severity estimation": "fire_burned_area_severity_estimation",
            "Sentinel-2 image": "fire_satellite_image_sentinel_2",
        }

        # Connect UI signals to methods
        # Login
        self.certificatesPushButton.clicked.connect(self.load_certificates)
        self.loginPushButton.clicked.connect(self.login)
        # Request
        self.startDateLineEdit.mousePressEvent = lambda _: self.move_calendar(
            "start_date"
        )
        self.endDateLineEdit.mousePressEvent = lambda _: self.move_calendar("end_date")
        self.startDateLineEdit.editingFinished.connect(self.update_dates)
        self.endDateLineEdit.editingFinished.connect(self.update_dates)
        self.calendarWidget.clicked.connect(self.add_calendar_date)

        self.requestPushButton.clicked.connect(self.start_listening)
        self.requestPushButton.clicked.connect(self.send_request)

    def move_calendar(self, active):
        """Moves calendar between the "start time" and "end time" line edit fields"""
        if active == "start_date":
            self.calendarSpacer.hide()
        else:
            self.calendarSpacer.show()
        self.active_time = active

    def update_dates(self):
        new_start_time = parse_date(self.startDateLineEdit.text())
        new_end_time = parse_date(self.endDateLineEdit.text())

        if new_start_time is None or new_end_time is None:
            self.update_status("Error: Invalid date format.", "error")
        elif new_start_time and new_end_time and new_start_time > new_end_time:
            self.update_status("Error: Start date must be before end date.", "error")
        else:
            self.startDateLineEdit.setText(new_start_time)
            self.endDateLineEdit.setText(new_end_time)

    def add_calendar_date(self):
        """Handles selected calendar date"""
        calendar_time = str(self.calendarWidget.selectedDate().toPyDate())

        if self.active_time == "start_date":
            self.startDateLineEdit.setText(calendar_time)
        else:
            self.endDateLineEdit.setText(calendar_time)

    def load_certificates(self, *_):
        folder = QFileDialog.getOpenFileName(self, "Select certificates file")
        self.certificatesLineEdit.setText(folder[0])

    def login(self, *_):
        if self.clientIdLineEdit.text():
            self.clientIdLineEdit.setEnabled(False)
            self.loginInfoLabel.setText("Login Successful✅")

    def send_request(self):
        """
        Sends a request to the RabbitMQ message broker with the selected parameters.

        This function collects and validates the user inputs, constructs a message containing
        the selected polygon layer's geometry, the chosen pipeline, and the time range. It
        then sends this message to a specific queue on the RabbitMQ.

        The process includes:

        - Validating the selected polygon layer and its features.
        - Constructing a unified geometry from all features in the layer.
        - Converting the geometry to WKT format and loading it as a Shapely polygon.
        - Constructing a message dictionary with the pipeline, geometry, and time range.
        - Publishing the message to the RabbitMQ server.

        If any error occurs during this process, it updates the status with an error message.

        :raises Exception: If an error occurs during message sending or connection setup.
        """

        # Retrieve user inputs
        selected_layer = self.mMapLayerComboBox.currentLayer()
        pipeline_text = self.layerTypeComboBox.currentText()
        start_dt = self.startDateLineEdit.text()
        end_dt = self.endDateLineEdit.text()
        user_id = self.clientIdLineEdit.text()

        # Input validation
        if not isinstance(selected_layer, QgsVectorLayer):
            self.update_status("Error: Please select a valid polygon layer.", "error")
            return

        all_geoms = [feature.geometry() for feature in selected_layer.getFeatures()]
        if not all_geoms:
            self.update_status("Error: The selected layer has no features.", "error")
            return

        unified_qgs_geom = QgsGeometry.unaryUnion(all_geoms)
        if unified_qgs_geom.isEmpty():
            self.update_status(
                "Error: Could not create a valid geometry from the layer.", "error"
            )
            return

        wkt_geometry = unified_qgs_geom.asWkt()
        shapely_polygon = wkt_loads(wkt_geometry)

        if not all([user_id, selected_layer]):
            self.update_status("Error: All fields are required to send.", "error")
            return

        # Start Processing
        try:
            self.update_status("Sending message...")
            credentials = pika.credentials.ExternalCredentials()
            context = ssl.create_default_context(cafile=self.ca_file)
            context.verify_mode = ssl.CERT_REQUIRED
            context.load_cert_chain(
                certfile=self.cert_file,
                keyfile=self.key_file,
            )
            ssl_options = pika.SSLOptions(context, server_hostname=self.host)
            connection_parameters = pika.ConnectionParameters(
                credentials=credentials,
                host=self.host,
                port=self.port,
                ssl_options=ssl_options,
                virtual_host=self.vhost,
            )

            connection = pika.BlockingConnection(connection_parameters)
            channel = connection.channel()

            message_dict = {
                "datatype_id": self.pipeline_map[pipeline_text],
                "geometry": mapping(shapely_polygon),
                "start": start_dt,
                "end": end_dt,
            }

            channel.basic_publish(
                exchange=self.exchange,
                routing_key=f"test.request.{user_id}",  # Route the message specifically to this user's queue
                body=json.dumps(message_dict),
                properties=pika.BasicProperties(
                    delivery_mode=2,
                    message_id=f"{user_id}.{str(uuid.uuid4())}",
                    user_id="links",
                ),
            )
            connection.close()
            self.update_status(f"Message sent to user '{user_id}'.", "info")
        except Exception as e:
            self.update_status(f"Error sending message: {e}", "error")

    def start_listening(self):
        """Set up the worker and thread to start listening for messages."""
        if self.thread is not None and self.thread.isRunning():
            self.update_status("Already listening.", "warning")
            return

        user_id = self.clientIdLineEdit.text()

        if not all([user_id]):
            self.update_status("Error: Connection fields are required.", "error")
            return

        # Create a QThread
        self.thread = QThread()
        # Create a worker
        self.worker = MainWorker(
            broker_ca_file=self.ca_file,
            broker_cert_file=self.cert_file,
            broker_key_file=self.key_file,
            user_id=user_id,
            exchange=self.exchange,
            host=self.host,
            port=self.port,
            vhost=self.vhost,
            datalake_oauth_user=self.datalake_oauth_user,
            datalake_oauth_password=self.datalake_oauth_password,
            datalake_oauth_app_id=self.datalake_oauth_app_id,
            datalake_oauth_api_key=self.datalake_oauth_api_key,
            datalake_auth_url=self.datalake_auth_url,
        )

        # Move worker to the thread
        self.worker.moveToThread(self.thread)

        # Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        # Connect the thread's finished signal to our cleanup method
        self.thread.finished.connect(self.cleanup_thread)

        self.worker.layer_ready.connect(self.load_layer)
        self.worker.status_updated.connect(self.update_status)
        self.worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.thread.start()

        # Disable button
        self.requestPushButton.setEnabled(False)
        self.update_status("Listener started. Waiting for messages...", "info")

    def load_layer(self, file_path):
        """Loads the downloaded file into QGIS. This runs on the main thread."""
        self.update_status(
            f"Processing downloaded file: {os.path.basename(file_path)}", "info"
        )
        layer_name = os.path.splitext(os.path.basename(file_path))[0]

        # --- HANDLE ZIP ARCHIVES ---
        if file_path.lower().endswith(".zip"):
            self.handle_zip_file(file_path, layer_name)
        # --- HANDLE SINGLE TIF/TIFF FILES ---
        elif file_path.lower().endswith((".tif", ".tiff")):
            self.handle_single_tif(file_path, layer_name)
            # --- HANDLE UNSUPPORTED FILES ---
        else:
            self.update_status(
                f"Warning: File type not supported for auto-loading: {file_path}",
                "warning",
            )

    def handle_single_tif(self, file_path, layer_name):
        """Loads a single TIF file as a QGIS layer."""
        self.update_status(f"Loading raster layer: {layer_name}", "info")
        layer = QgsRasterLayer(file_path, layer_name)

        if not layer.isValid():
            self.update_status(
                f"Error: Failed to load raster layer {layer_name}", "error"
            )
            return

        QgsProject.instance().addMapLayer(layer)
        self.update_status(f"Successfully loaded {layer_name}", "success")

    def handle_zip_file(self, zip_path, group_name):
        """
        Unzips an archive and loads all contained .tif files into a new layer group.
        """
        # Use a temporary directory that is automatically cleaned up

        extract_dir = tempfile.mkdtemp(prefix="qgis_ermes_")
        self.temp_dirs_to_clean.append(extract_dir)

        self.update_status(
            f"Unzipping '{os.path.basename(zip_path)}' to a temporary location...",
            "info",
        )

        try:
            # Extract the zip file
            with zipfile.ZipFile(zip_path, "r") as zip_ref:
                zip_ref.extractall(extract_dir)
            try:
                os.remove(zip_path)
                self.update_status(
                    f"Removed original archive: {os.path.basename(zip_path)}", "info"
                )
            except OSError as e:
                self.update_status(
                    f"Warning: Could not remove original zip file {zip_path}: {e}",
                    "warning",
                )
        except zipfile.BadZipFile:
            self.update_status(
                f"Error: '{os.path.basename(zip_path)}' is not a valid zip file.",
                "error",
            )
            return
        except Exception as e:
            self.update_status(f"Error extracting zip file: {e}", "error")
            return

        # Scan the extracted directory for .tif files
        tiff_files = []
        for root_dir, _, files in os.walk(extract_dir):
            for file in files:
                if file.lower().endswith((".tif", ".tiff")):
                    tiff_files.append(os.path.join(root_dir, file))

        if not tiff_files:
            self.update_status(
                f"No .tif files were found inside '{os.path.basename(zip_path)}'.",
                "warning",
            )
            return

        # Get the project instance and the root of the layer tree
        project = QgsProject.instance()
        root = project.layerTreeRoot()

        # Create a new group in the layer tree. The group_name comes from layer_name.
        group = root.addGroup(group_name)

        loaded_count = 0
        for tiff_path in tiff_files:
            # Use the tif's own filename as the layer name
            individual_layer_name = os.path.splitext(os.path.basename(tiff_path))[0]

            layer = QgsRasterLayer(tiff_path, individual_layer_name)
            if not layer.isValid():
                self.update_status(
                    f"Skipping invalid raster: {individual_layer_name}", "warning"
                )
                continue

            # Add the layer to the project's internal registry, but NOT to the legend yet (False).
            # This prevents it from appearing at the top level.
            project.addMapLayer(layer, False)

            # Now, add the layer to our newly created group.
            group.addLayer(layer)
            loaded_count += 1

        self.update_status(
            f"Successfully loaded {loaded_count} layer(s) into group '{group_name}'.",
            "success",
        )

    def update_status(self, message, level="info"):
        """Updates the status label and logs to QGIS log."""
        self.textLogger.setText(message)
        log_level = Qgis.Info
        if level == "error":
            log_level = Qgis.Critical
        elif level == "warning":
            log_level = Qgis.Warning
        elif level == "success":
            log_level = Qgis.Success

        QgsMessageLog.logMessage(message, "RabbitMQ_Listener", level=log_level)

    def closeEvent(self, event):
        """Ensure the thread is stopped when the dialog is closed."""
        self.update_status("Closing dialog, stopping listener...")
        if self.thread and self.thread.isRunning():
            self.worker.stop()
            self.thread.quit()
            self.thread.wait()  # Wait for the thread to finish
        event.accept()

    def cleanup_thread(self):
        """
        Cleans up thread and worker references after the thread has finished.
        This slot is connected to the thread's finished signal.
        """
        self.update_status("Listener stopped.", "info")

        # Re-enable the button so the user can start another listener
        self.requestPushButton.setEnabled(True)

        # Set the Python references to None
        self.thread = None
        self.worker = None

    def cleanup_temp_dirs(self):
        """
        This function is called when QGIS is about to quit.
        It safely removes all temporary directories created during the session.
        """
        self.update_status(
            f"Cleaning up {len(self.temp_dirs_to_clean)} temporary directories...",
            "info",
        )
        for dir_path in self.temp_dirs_to_clean:
            try:
                # shutil.rmtree can remove a directory and all its contents
                shutil.rmtree(dir_path)
            except Exception as e:
                # Log an error but don't prevent QGIS from closing
                print(f"Could not remove temporary directory {dir_path}: {e}")
                self.update_status(
                    f"Warning: Could not remove temp dir {dir_path}", "warning"
                )

        self.temp_dirs_to_clean.clear()
