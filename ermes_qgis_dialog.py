# -*- coding: utf-8 -*-
"""
/***************************************************************************
  ErmesQGISDialog
                                 A QGIS plugin
 Integration of ERMES model in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gaetano Chiriaco - Links Foundation
        email                : gaetano.chiriaco@linksfoundation.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import os
import requests
import shutil
import tempfile
import zipfile
from datetime import datetime
import json
from qgis.core import (
    QgsRasterLayer,
    QgsProject,
    QgsGeometry,
    QgsVectorLayer,
    QgsApplication,
    QgsWkbTypes,
    QgsRectangle,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
)
from qgis.utils import iface
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QTableWidgetItem, QHeaderView, QDockWidget
from qgis.PyQt.QtCore import QThread, QTimer
from qgis.core import QgsMapLayerProxyModel

# Store job data in the row for later use
from PyQt5.QtCore import Qt

# Import the workers from their new modules
from .workers.job import JobsWorker
from .workers.main import MainWorker
from .workers.token_manager import TokenManager

# Import the BoundingBoxWidget
from .widgets.bbox_widget import RectangleMapTool

import warnings

warnings.filterwarnings("ignore")
base_path = os.path.dirname(os.path.abspath(__file__))
thumbnail_image = os.path.join(base_path, "images", "title.png")


def parse_date(date: str) -> str:
    """If a date string is set it parses it into a format YYYY-MM-DD. In case parsing fails None is returned.

    :param date: A string describing a date
    :return: A string in a format YYYY-MM-DD, an empty string, or None
    """
    if date == "":
        return date
    try:
        return datetime.fromisoformat(date).isoformat()
    except ValueError:
        return None


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")
)


class ErmesQGISDialog(QDockWidget):
    def __init__(self, parent=None):
        super(ErmesQGISDialog, self).__init__(parent)

        # Set dock widget properties
        self.setWindowTitle("ERMES for QGIS")
        self.setAllowedAreas(Qt.RightDockWidgetArea | Qt.LeftDockWidgetArea)
        self.setFeatures(
            QDockWidget.DockWidgetMovable
            | QDockWidget.DockWidgetFloatable
            | QDockWidget.DockWidgetClosable
        )

        # Load the UI file and set it as the widget for the dock
        ui_file = os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")

        # Create a widget to hold the UI content
        self.content_widget = QtWidgets.QWidget()
        uic.loadUi(ui_file, self.content_widget)

        # Set the content widget as the widget for the dock
        self.setWidget(self.content_widget)

        # Create a helper to access UI elements more easily
        self.ui = self.content_widget

        # Initialize the plugin
        self._initialize_plugin()

    def __getattr__(self, name):
        """Redirect attribute access to UI elements"""
        try:
            return getattr(self.ui, name)
        except AttributeError:
            raise AttributeError(
                f"'{self.__class__.__name__}' object has no attribute '{name}'"
            )

    def _initialize_plugin(self):
        """Initialize plugin-specific data and settings"""
        # Setup for temporary directory management
        self.temp_dirs_to_clean = []
        QgsApplication.instance().aboutToQuit.connect(self.cleanup_temp_dirs)

        # Worker utils
        self.thread = None
        self.worker = None

        # Jobs tab worker utils
        self.jobs_thread = None
        self.jobs_worker = None
        self.jobs_timer = None

        # Initialize plugin data
        self._initialize_plugin_data()

    def _initialize_plugin_data(self):
        """Initialize plugin-specific data and settings"""
        # Setup for API
        self.active_time = None
        self.api_base_url = "https://loki.linksfoundation.com/ermes-plugin"
        self.username = None  # Will be set when user logs in
        self.password = None  # Will be set when user logs in
        self.access_token = None  # Will be set after successful login
        self.token_manager = TokenManager(self.api_base_url)

        # Initialize tab state - disable all tabs except login since no token yet
        self.tabWidget.setTabEnabled(1, False)  # Request
        self.tabWidget.setTabEnabled(2, False)  # From Layer
        self.tabWidget.setTabEnabled(3, False)  # Jobs
        self.tabWidget.setCurrentIndex(0)  # Switch to Login tab

        # Token validation timer
        self.token_timer = QTimer()
        self.token_timer.timeout.connect(self.check_token_validity)
        self.token_timer.setInterval(60000)  # Check every minute

        self.polygonLayerComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.rasterLayerComboBox.setFilters(QgsMapLayerProxyModel.RasterLayer)

        # Initialize BoundingBoxWidget
        self.bboxWidget = None
        self.rectangleMapTool = None
        self.current_bbox = None  # Store current bounding box coordinates

        # Available pipelines
        self.pipeline_map = {
            "Burned area delineation": "fire_burned_area_delineation",
            "Burn Severity estimation": "fire_burned_area_severity_estimation",
            "Active Flames and Smoke detection": "fire_active_flames_and_smoke_detection",
            "Waterbody delineation": "flood_post_waterbody_delineation",
            "Sentinel-2 image": "fire_satellite_image_sentinel_2",
            "Sentinel-1 image": "flood_satellite_image_sentinel_1",
        }

        # Available image types
        self.image_type_map = {
            "Sentinel-2 image": "sentinel_2",
            "Sentinel-1 image": "sentinel_1",
        }
        # Available styles
        self.style_root = "styles"
        self.style_map = {
            "fire_burned_area_delineation": "fire_burned_area_delineation.qml",
            "fire_burned_area_severity_estimation": "fire_burned_area_severity_estimation.qml",
            "fire_active_flames_and_smoke_detection": "fire_active_flames_and_smoke_detection.qml",
            "flood_post_waterbody_delineation": "flood_post_waterbody_delineation.qml",
            "fire_satellite_image_sentinel_2": "fire_satellite_image_sentinel_2.qml",
            "flood_satellite_image_sentinel_1": "flood_satellite_image_sentinel_1.qml",
        }

        # Setup jobs table
        self.setup_jobs_table()

        # Initialize status messages list
        self.status_messages = []
        self._cached_messages = []

        # Connect UI signals to methods
        # Login
        self.loginPushButton.clicked.connect(self.login)
        self.logoutButton.clicked.connect(self.perform_logout)
        # Request
        self.startDateLineEdit.mousePressEvent = lambda _: self.move_calendar(
            "start_date"
        )
        self.endDateLineEdit.mousePressEvent = lambda _: self.move_calendar("end_date")
        self.startDateLineEdit.editingFinished.connect(self.update_dates)
        self.endDateLineEdit.editingFinished.connect(self.update_dates)
        self.calendarWidget.clicked.connect(self.add_calendar_date)

        # Connect validation signals
        self.startDateLineEdit.textChanged.connect(self.validate_form_request)
        self.endDateLineEdit.textChanged.connect(self.validate_form_request)
        self.polygonLayerComboBox.layerChanged.connect(self.validate_form_request)

        # Connect radio button signals for AOI method selection
        self.drawRectangleRadioButton.toggled.connect(self.on_aoi_method_changed)
        self.selectPolygonRadioButton.toggled.connect(self.on_aoi_method_changed)

        self.requestPushButton.clicked.connect(self.send_request)

        # From Layer
        self.rasterLayerComboBox.layerChanged.connect(self.validate_form_from_layer)
        self.imageTypeComboBox.currentTextChanged.connect(
            self.update_requested_layer_options
        )
        self.imageTypeComboBox.currentTextChanged.connect(self.validate_form_from_layer)
        self.requestedLayerComboBox.currentTextChanged.connect(
            self.validate_form_from_layer
        )
        self.requestFilePushButton.clicked.connect(self.send_request_from_layer)

        # Jobs tab
        self.downloadJobButton.clicked.connect(self.download_selected_jobs)
        self.deleteJobButton.clicked.connect(self.delete_selected_jobs)
        self.refreshJobsButton.clicked.connect(self.refresh_jobs_table)

        # Initial validation
        self.validate_form_request()
        self.validate_form_from_layer()

        # Initialize requested layer options
        self.update_requested_layer_options()

        # Initialize AOI method
        self.on_aoi_method_changed()

    def setup_jobs_table(self):
        """Setup the jobs table with appropriate columns"""
        # Assuming the table is named jobsTableWidget
        if hasattr(self, "jobsTableWidget"):
            self.jobsTableWidget.setColumnCount(7)
            self.jobsTableWidget.setHorizontalHeaderLabels(
                [
                    "ID",
                    "Pipeline",
                    "Status",
                    "Status Message",
                    "Created",
                    "Start Date",
                    "End Date",
                ]
            )

            # Set column widths
            header = self.jobsTableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)  # ID
            header.setSectionResizeMode(1, QHeaderView.Stretch)  # Pipeline
            header.setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Status
            header.setSectionResizeMode(
                3, QHeaderView.ResizeToContents
            )  # Status Message
            header.setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Created
            header.setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Start Date
            header.setSectionResizeMode(6, QHeaderView.ResizeToContents)  # End Date

            # Enable selection
            self.jobsTableWidget.setSelectionBehavior(
                QtWidgets.QAbstractItemView.SelectRows
            )
            self.jobsTableWidget.setSelectionMode(
                QtWidgets.QAbstractItemView.MultiSelection
            )

    def start_jobs_monitoring(self):
        """Start monitoring jobs from the API"""
        try:
            if self.jobs_thread is not None and self.jobs_thread.isRunning():
                self.update_status("Already monitoring jobs.", "warning")
                return
        except Exception as e:
            # If the jobs_thread is not initialized, create it
            pass

        # Create a QThread for jobs monitoring
        self.jobs_thread = QThread()
        # Create a jobs worker
        self.jobs_worker = JobsWorker(
            api_base_url=self.api_base_url, access_token=self.access_token
        )

        # Move worker to the thread
        self.jobs_worker.moveToThread(self.jobs_thread)

        # Connect signals and slots
        self.jobs_thread.started.connect(self.jobs_worker.run)
        self.jobs_worker.finished.connect(self.jobs_thread.quit)
        self.jobs_worker.finished.connect(self.jobs_worker.deleteLater)
        self.jobs_thread.finished.connect(self.jobs_thread.deleteLater)

        # Connect worker signals
        self.jobs_worker.jobs_updated.connect(self.update_jobs_table)
        self.jobs_worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.jobs_thread.start()

    def update_jobs_table(self, jobs):
        """Update the jobs table with the latest jobs data"""
        if not hasattr(self, "jobsTableWidget"):
            return

        self.jobsTableWidget.setRowCount(0)  # Clear existing rows

        for job in jobs:
            # Show all jobs regardless of status
            row = self.jobsTableWidget.rowCount()
            self.jobsTableWidget.insertRow(row)

            datatype_id = job.get("body", {}).get("datatype_id", "")
            start_date = job.get("body", {}).get("start_date", "")
            end_date = job.get("body", {}).get("end_date", "")

            # Add job data to table
            self.jobsTableWidget.setItem(
                row, 0, QTableWidgetItem(str(job.get("id", "")))
            )
            self.jobsTableWidget.setItem(row, 1, QTableWidgetItem(datatype_id))
            self.jobsTableWidget.setItem(
                row, 2, QTableWidgetItem(job.get("status", ""))
            )
            self.jobsTableWidget.setItem(
                row, 3, QTableWidgetItem(job.get("result", ""))
            )
            self.jobsTableWidget.setItem(
                row, 4, QTableWidgetItem(job.get("created_at", ""))
            )
            self.jobsTableWidget.setItem(row, 5, QTableWidgetItem(start_date))
            self.jobsTableWidget.setItem(row, 6, QTableWidgetItem(end_date))

            self.jobsTableWidget.item(row, 0).setData(Qt.UserRole, job)

    def download_selected_jobs(self):
        """Download and load selected jobs into QGIS"""
        selected_rows = set()
        for item in self.jobsTableWidget.selectedItems():
            selected_rows.add(item.row())

        if not selected_rows:
            self.update_status("No jobs selected for download.", "warning")
            return

        # Filter jobs that can be downloaded (end status with resource_url)
        downloadable_jobs = []
        non_downloadable_jobs = []

        for row in selected_rows:
            try:
                # Get job data from the table
                job_item = self.jobsTableWidget.item(row, 0)
                if job_item:
                    job_data = job_item.data(Qt.UserRole)
                    job_id = job_data.get("id")
                    job_status = job_data.get("status")
                    resource_url = job_data.get("resource_url")

                    if job_status == "end" and resource_url:
                        downloadable_jobs.append((row, job_id))
                    else:
                        non_downloadable_jobs.append(job_id)

            except Exception as e:
                self.update_status(
                    f"Internal error processing job from row {row}", "error"
                )

        # Show warning for non-downloadable jobs
        if non_downloadable_jobs:
            self.update_status(
                f"Warning: Jobs {non_downloadable_jobs} cannot be downloaded (not completed or no resource available).",
                "warning",
            )

        if not downloadable_jobs:
            self.update_status("No downloadable jobs selected.", "warning")
            return

        self.update_status(
            f"Downloading {len(downloadable_jobs)} selected job(s)...", "info"
        )

        for row, job_id in downloadable_jobs:
            try:
                # Download the job resource
                self.download_job_resource(job_id)
            except Exception as e:
                self.update_status(
                    f"Internal error downloading resource for job {job_id}", "error"
                )

    def download_job_resource(self, job_id):
        """Download a specific job resource and load it into QGIS"""

        try:
            # First, get the job details to retrieve the datatype_id
            job_url = f"{self.api_base_url}/jobs/{job_id}"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            job_response = requests.get(job_url, headers=headers)
            job_response.raise_for_status()
            job_data = job_response.json()

            # Extract datatype_id from the job data
            datatype_id = job_data.get("body", {}).get("datatype_id", None)

            # Use the same download logic as in MainWorker
            retrieve_url = f"{self.api_base_url}/retrieve/{job_id}"

            self.update_status(f"Downloading job {job_id}...", "info")

            with requests.get(retrieve_url, headers=headers, stream=True) as response:
                response.raise_for_status()

                # Get filename from Content-Disposition header
                content_disp = response.headers.get("Content-Disposition", "")
                filename = None
                if "filename=" in content_disp:
                    filename = content_disp.split("filename=")[-1].strip('"; ')
                if not filename:
                    filename = f"{job_id}.zip"

                # Use a temporary directory to save the file
                with tempfile.TemporaryDirectory(
                    prefix=f"qgis_ermes_{job_id}_"
                ) as temp_dir:
                    cache_path = os.path.join(temp_dir, filename)

                    with open(cache_path, "wb") as f:
                        for chunk in response.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)

                    # Load the downloaded file into QGIS with datatype_id
                    self.load_layer(cache_path, datatype_id)
                # Temporary directory and file are automatically cleaned up here

        except Exception as e:
            self.update_status(f"Internal error downloading job {job_id}", "error")

    def delete_selected_jobs(self):
        """Mock delete functionality for selected jobs"""
        selected_rows = set()
        for item in self.jobsTableWidget.selectedItems():
            selected_rows.add(item.row())

        if not selected_rows:
            self.update_status("No jobs selected for deletion.", "warning")
            return

        # Mock behavior - just show a message
        self.update_status(
            f"Mock: Would delete {len(selected_rows)} selected job(s). This functionality is not yet implemented.",
            "info",
        )

        # In a real implementation, you would:
        # 1. Call the API to delete the jobs
        # 2. Remove the rows from the table
        # 3. Update the jobs list

    def refresh_jobs_table(self):
        """Refreshes the jobs table by re-fetching jobs from the API."""
        if not self.access_token:
            self.update_status("Error: Please login before refreshing jobs.", "error")
            return

        # Check token validity before making request
        if not self.token_manager.check_and_handle_expiration():
            self.perform_logout()
            self.update_status("Session expired. Please login again.", "warning")
            return

        self.update_status("Refreshing jobs table...", "info")

        try:
            # Call the API directly to get jobs
            headers = {"Authorization": f"Bearer {self.access_token}"}
            jobs_url = f"{self.api_base_url}/jobs/"

            response = requests.get(jobs_url, headers=headers)
            response.raise_for_status()

            jobs = response.json()["jobs"]
            self.update_jobs_table(jobs)
            self.update_status(
                f"Successfully refreshed jobs table with {len(jobs)} jobs.", "success"
            )

        except requests.exceptions.RequestException as e:
            self.update_status(f"Failed to fetch jobs to refresh jobs table", "error")
        except Exception as e:
            self.update_status(f"Internal error refreshing jobs table", "error")

    def move_calendar(self, active):
        """Moves calendar between the "start time" and "end time" line edit fields"""
        if active == "start_date":
            self.calendarSpacer.hide()
        else:
            self.calendarSpacer.show()
        self.active_time = active

    def update_dates(self):
        new_start_time = parse_date(self.startDateLineEdit.text())
        new_end_time = parse_date(self.endDateLineEdit.text())

        if new_start_time is None or new_end_time is None:
            self.update_status("Invalid date format.", "error")
        elif new_start_time and new_end_time and new_start_time > new_end_time:
            self.update_status("Start date must be before end date.", "warning")
        elif new_start_time and datetime.fromisoformat(
            new_start_time
        ) > datetime.now().replace(tzinfo=None):
            self.update_status("Start date must be before the current date.", "warning")
        elif new_end_time and datetime.fromisoformat(
            new_end_time
        ) > datetime.now().replace(tzinfo=None):
            self.update_status("End date must be before the current date.", "warning")
        else:
            self.startDateLineEdit.setText(new_start_time)
            self.endDateLineEdit.setText(new_end_time)

    def add_calendar_date(self):
        """Handles selected calendar date"""
        calendar_time = str(self.calendarWidget.selectedDate().toPyDate())

        if self.active_time == "start_date":
            self.startDateLineEdit.setText(calendar_time)
        else:
            self.endDateLineEdit.setText(calendar_time)

    def login(self, *_):
        """
        Handles user login. Reads username and password from the UI,
        sends them to the API, and if successful, enables the Request and Jobs tabs.
        """
        username = (
            self.usernameLineEdit.text().strip()
            if hasattr(self, "usernameLineEdit")
            else ""
        )
        password = (
            self.passwordLineEdit.text().strip()
            if hasattr(self, "passwordLineEdit")
            else ""
        )

        if not username or not password:
            self.loginInfoLabel.setText("Please enter both username and password.")
            return

        self.loginPushButton.setEnabled(False)
        self.loginInfoLabel.setText("Logging in...")

        try:
            auth_url = f"{self.api_base_url}/auth/login"
            auth_data = {
                "username": username,
                "password": password,
            }
            response = requests.post(auth_url, data=auth_data)
            response.raise_for_status()
            token_data = response.json()
            self.access_token = token_data.get("access_token")
            if not self.access_token:
                self.loginInfoLabel.setText("Login failed: No token received.")
                self.loginPushButton.setEnabled(True)
                return

            # Save credentials for later use
            self.username = username
            self.password = password

            # Set token in token manager
            self.token_manager.set_token(self.access_token)

            self.loginInfoLabel.setText("Login Successful ✅")
            # Enable the Request and Jobs tabs
            self.tabWidget.setTabEnabled(1, True)
            self.tabWidget.setTabEnabled(2, True)
            self.tabWidget.setTabEnabled(3, True)
            # Optionally, switch to the Request tab automatically
            self.tabWidget.setCurrentIndex(1)

            self.logoutButton.setEnabled(True)

            # Start token validation timer
            self.token_timer.start()

            # Start monitoring jobs
            self.start_jobs_monitoring()

        except requests.HTTPError as http_err:
            if http_err.response is not None:
                status_code = http_err.response.status_code
                try:
                    error_json = http_err.response.json()
                    error_detail = error_json.get("detail", str(error_json))
                except Exception:
                    error_detail = http_err.response.text

                if status_code == 401:
                    self.loginInfoLabel.setText(
                        "Login failed: Unauthorized (401). Please check your username and password."
                    )
                elif status_code == 403:
                    self.loginInfoLabel.setText(
                        "Login failed: Forbidden (403). You do not have access."
                    )
                elif status_code == 500:
                    self.loginInfoLabel.setText(
                        "Login failed: Server error (500). Please try again later."
                    )
                else:
                    self.loginInfoLabel.setText(
                        f"Login failed ({status_code}): {error_detail}"
                    )
            else:
                self.loginInfoLabel.setText("Login failed: HTTP error occurred.")
            self.loginPushButton.setEnabled(True)
        except requests.ConnectionError:
            self.loginInfoLabel.setText(
                "Login failed: Unable to connect to server. Please check your network connection."
            )
            self.loginPushButton.setEnabled(True)
        except requests.Timeout:
            self.loginInfoLabel.setText(
                "Login failed: Request timed out. Please try again."
            )
            self.loginPushButton.setEnabled(True)
        except Exception as e:
            self.loginInfoLabel.setText(f"Login failed: Internal error {e}")
            self.loginPushButton.setEnabled(True)

    def send_request(self):
        """
        Sends a request to the API with the selected parameters.

        This function collects and validates the user inputs, constructs a message containing
        the selected polygon layer's geometry, the chosen pipeline, and the time range. It
        then sends this message to the API.

        The process includes:

        - Validating the selected polygon layer and its features.
        - Constructing a unified geometry from all features in the layer.
        - Constructing a message dictionary with the pipeline, geometry, and time range.
        - Publishing the message to the API.

        If any error occurs during this process, it updates the status with an error message.

        :raises Exception: If an error occurs during message sending or connection setup.
        """

        # Check if logged in
        if not self.access_token:
            self.update_status("Error: Please login before making a request.", "error")
            return

        # Check token validity before making request
        if not self.token_manager.check_and_handle_expiration():
            self.perform_logout()
            self.update_status("Session expired. Please login again.", "warning")
            return

        # Retrieve user inputs
        pipeline_text = self.layerTypeComboBox.currentText()
        start_dt = self.startDateLineEdit.text()
        end_dt = self.endDateLineEdit.text()

        # Get geometry based on AOI method
        if self.drawRectangleRadioButton.isChecked():
            # Use drawn rectangle
            if not self.current_bbox:
                self.update_status("Error: Please draw a rectangle first.", "error")
                return

            # Create geometry from bbox coordinates (already in EPSG:4326 from bbox_widget)
            minx, miny, maxx, maxy = self.current_bbox

            rect = QgsRectangle(minx, miny, maxx, maxy)
            unified_qgs_geom = QgsGeometry.fromRect(rect)
        else:
            # Use selected polygon layer
            selected_layer = self.polygonLayerComboBox.currentLayer()
            if not isinstance(selected_layer, QgsVectorLayer):
                self.update_status(
                    "Error: Please select a valid polygon layer.", "error"
                )
                return

            all_geoms = [feature.geometry() for feature in selected_layer.getFeatures()]
            if not all_geoms:
                self.update_status(
                    "Error: The selected layer has no features.", "error"
                )
                return

            unified_qgs_geom = QgsGeometry.unaryUnion(all_geoms)
            if unified_qgs_geom.isEmpty():
                self.update_status(
                    "Error: Could not create a valid geometry from the layer.", "error"
                )
                return

            # Transform geometry to EPSG:4326 if needed
            layer_crs = selected_layer.crs()
            target_crs = QgsCoordinateReferenceSystem("EPSG:4326")

            if layer_crs != target_crs:
                try:
                    transform = QgsCoordinateTransform(
                        layer_crs, target_crs, QgsProject.instance()
                    )
                    unified_qgs_geom.transform(transform)
                    self.update_status(
                        f"Transformed geometry from {layer_crs.authid()} to EPSG:4326",
                        "info",
                    )
                except Exception as e:
                    self.update_status(f"Error transforming geometry: {e}", "error")
                    return

        geometry_str = unified_qgs_geom.asJson()

        try:
            geometry = json.loads(geometry_str)
        except Exception as e:
            self.update_status(f"Error parsing geometry JSON: {e}", "error")
            return

        # Start Processing
        try:
            self.update_status("Sending request to API...")

            # Use the saved access token for authentication
            headers = {"Authorization": f"Bearer {self.access_token}"}

            # Create job request
            job_url = f"{self.api_base_url}/jobs/create"
            job_data = {
                "datatype_id": self.pipeline_map[pipeline_text],
                "geometry": geometry,
                "start_date": start_dt,
                "end_date": end_dt,
            }

            job_response = requests.post(job_url, json=job_data, headers=headers)
            job_response.raise_for_status()

            job_result = job_response.json()
            job_id = job_result["id"]
            self.add_log_separator()
            self.update_status(f"Job created with ID: {job_id}", "info")

            # Start monitoring the job
            self.start_listening(job_id)

        except Exception as e:
            self.update_status(f"Error sending request: {e}", "error")

    def send_request_from_layer(self):
        """Sends a request to the API with the selected parameters, uploading the raster file."""
        if not self.access_token:
            self.update_status("Error: Please login before making a request.", "error")
            return

        # Retrieve user inputs
        selected_layer = self.rasterLayerComboBox.currentLayer()
        image_type = self.imageTypeComboBox.currentText()
        requested_layer = self.requestedLayerComboBox.currentText()

        # Input validation
        if not isinstance(selected_layer, QgsRasterLayer):
            self.update_status("Error: Please select a valid raster layer.", "error")
            return

        # Get the file path of the raster layer
        file_path = selected_layer.source()
        if not file_path or not file_path.lower().endswith((".tif", ".tiff")):
            self.update_status(
                "Error: The selected raster layer must be a TIFF file.", "error"
            )
            return

        # Start Processing
        try:
            self.update_status("Sending request to API...")

            # Use the saved access token for authentication
            headers = {"Authorization": f"Bearer {self.access_token}"}

            # Prepare the API endpoint and parameters
            job_url = f"{self.api_base_url}/jobs/create/from_file"
            params = {
                "datatype_id": self.pipeline_map[requested_layer],
                "image_type": self.image_type_map[image_type],
            }

            # Open the raster file for upload
            with open(file_path, "rb") as f:
                files = {
                    "file": (os.path.basename(file_path), f, "image/tiff"),
                }
                response = requests.post(
                    job_url, headers=headers, params=params, files=files
                )
                response.raise_for_status()

            # If the API returns a file (StreamingResponse), save it to a temp file and load it
            content_type = response.headers.get("Content-Type", "")
            if "image/tiff" in content_type or "image/tif" in content_type:
                import tempfile

                temp_tiff = tempfile.NamedTemporaryFile(delete=False, suffix=".tif")
                temp_tiff.write(response.content)
                temp_tiff.close()
                self.update_status(
                    "Received result TIFF from API. Loading into QGIS...", "success"
                )
                self.load_layer(temp_tiff.name, self.pipeline_map[requested_layer])
            else:
                # If the API returns JSON (e.g., error), show the message
                try:
                    error_json = response.json()
                    error_msg = error_json.get("detail", str(error_json))
                except Exception:
                    error_msg = response.text
                self.update_status(
                    f"Internal error sending request from layer", "error"
                )

        except Exception as e:
            self.update_status(f"Internal error sending request from layer", "error")

    def start_listening(self, job_id):
        """Set up the worker and thread to start monitoring the job."""
        if self.thread is not None and self.thread.isRunning():
            self.update_status("Already monitoring a job.", "warning")
            return

        # Create a QThread
        self.thread = QThread()
        # Create a worker
        self.worker = MainWorker(
            api_base_url=self.api_base_url,
            username=self.username,
            password=self.password,
            job_id=job_id,
        )

        # Move worker to the thread
        self.worker.moveToThread(self.thread)

        # Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        # Connect the thread's finished signal to our cleanup method
        self.thread.finished.connect(self.cleanup_thread)

        self.worker.layer_ready.connect(self.load_layer)
        self.worker.status_updated.connect(self.update_status)
        self.worker.log_separator.connect(self.add_log_separator)
        self.worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.thread.start()

        # Disable button
        self.requestPushButton.setEnabled(False)
        self.update_status(f"Started monitoring job {job_id}...", "info")

    def load_layer(self, file_path, datatype_id=None):
        """Loads the downloaded file into QGIS. This runs on the main thread."""
        self.update_status(
            f"Loading retrieved layer: {os.path.basename(file_path)}", "info"
        )
        layer_name = os.path.splitext(os.path.basename(file_path))[0]

        # --- HANDLE ZIP ARCHIVES ---
        if file_path.lower().endswith(".zip"):
            self.handle_zip_file(file_path, layer_name, datatype_id)
        # --- HANDLE SINGLE TIF/TIFF FILES ---
        elif file_path.lower().endswith((".tif", ".tiff")):
            self.handle_single_tif(file_path, layer_name, datatype_id)
        # --- HANDLE UNSUPPORTED FILES ---
        else:
            self.update_status(
                f"Warning: File type not supported for auto-loading: {file_path}",
                "warning",
            )

    def handle_single_tif(self, file_path, layer_name, datatype_id=None):
        """Loads a single TIF file as a QGIS layer and applies a style."""
        self.update_status(f"Loading raster layer: {layer_name}", "info")
        layer = QgsRasterLayer(file_path, layer_name)

        if not layer.isValid():
            self.update_status(
                f"Error: Failed to load raster layer {layer_name}", "error"
            )
            return

        # Apply style if datatype_id is available and in the style map
        if datatype_id and datatype_id in self.style_map:
            style_filename = self.style_map[datatype_id]
            style_path = os.path.join(
                os.path.dirname(__file__), self.style_root, style_filename
            )

            if os.path.exists(style_path):
                loaded = layer.loadNamedStyle(style_path)
                layer.triggerRepaint()
                if loaded[0]:
                    self.update_status(f"Applied style from {style_filename}", "info")
                else:
                    self.update_status(
                        f"Applied style from {style_filename} (QGIS returned warning: {loaded[1]})",
                        "info",
                    )
            else:
                self.update_status(
                    f"Warning: Style file not found: {style_path}", "warning"
                )
        else:
            self.update_status(
                "No style applied - datatype_id not available or not in style map.",
                "info",
            )

        QgsProject.instance().addMapLayer(layer, addToLegend=True)
        # Move the layer to position 0 (top of the layer tree)
        root = QgsProject.instance().layerTreeRoot()
        node = root.findLayer(layer.id())
        if node is not None:
            root.insertChildNode(0, node.clone())
            root.removeChildNode(node)
        self.update_status(f"Successfully loaded {layer_name}", "success")
        self.add_log_separator()

    def handle_zip_file(self, zip_path, group_name, datatype_id=None):
        """
        Unzips an archive and loads all contained .tif files into a new layer group, applying a style to each.
        """
        # Use a temporary directory that is automatically cleaned up

        extract_dir = tempfile.mkdtemp(prefix="qgis_ermes_")
        self.temp_dirs_to_clean.append(extract_dir)

        try:
            # Extract the zip file
            with zipfile.ZipFile(zip_path, "r") as zip_ref:
                zip_ref.extractall(extract_dir)
            try:
                os.remove(zip_path)
            except OSError as e:
                self.update_status(
                    f"Warning: Could not remove original zip file at location{zip_path}",
                    "warning",
                )
        except zipfile.BadZipFile:
            self.update_status(
                f"Error: '{os.path.basename(zip_path)}' is not a valid zip file",
                "error",
            )
            return
        except Exception as e:
            self.update_status(f"Error extracting zip file", "error")
            return

        # Scan the extracted directory for .tif files
        tiff_files = []
        for root_dir, _, files in os.walk(extract_dir):
            for file in files:
                if file.lower().endswith((".tif", ".tiff")):
                    tiff_files.append(os.path.join(root_dir, file))

        if not tiff_files:
            self.update_status(
                f"No .tif files were found inside '{os.path.basename(zip_path)}'",
                "warning",
            )
            return

        # Get the project instance and the root of the layer tree
        project = QgsProject.instance()
        root = project.layerTreeRoot()

        # Create a new group in the layer tree at position 0. The group_name comes from layer_name.
        group = root.insertGroup(0, group_name)

        # Get style path if datatype_id is available and in the style map
        style_path = None
        if datatype_id and datatype_id in self.style_map:
            style_filename = self.style_map[datatype_id]
            style_path = os.path.join(
                os.path.dirname(__file__), self.style_root, style_filename
            )

        loaded_count = 0
        for tiff_path in tiff_files:
            # Use the tif's own filename as the layer name
            individual_layer_name = os.path.splitext(os.path.basename(tiff_path))[0]

            layer = QgsRasterLayer(tiff_path, individual_layer_name)
            if not layer.isValid():
                self.update_status(
                    f"Skipping invalid raster: {individual_layer_name}",
                    "warning",
                )
                continue

            # Apply style if available
            if style_path and os.path.exists(style_path):
                loaded = layer.loadNamedStyle(style_path)
                if loaded[0]:
                    layer.triggerRepaint()
                    self.update_status(
                        f"Applied style to {individual_layer_name} from {os.path.basename(style_path)}",
                        "info",
                    )
                else:
                    pass
            else:
                if datatype_id and datatype_id in self.style_map:
                    self.update_status(
                        f"Style file not found for {individual_layer_name}, loading without style",
                        "warning",
                    )
                else:
                    self.update_status(
                        f"No style applied to {individual_layer_name} - datatype_id not available or not in style map",
                        "info",
                    )

            # Add the layer to the project's internal registry, but NOT to the legend yet (False).
            # This prevents it from appearing at the top level.
            project.addMapLayer(layer, False)

            # Now, add the layer to our newly created group.
            group.addLayer(layer)
            loaded_count += 1

        self.update_status(
            f"Successfully loaded {loaded_count} layer(s) into group '{group_name}'",
            "success",
        )
        self.add_log_separator()

    def add_log_separator(self):
        """Adds a separator to the log."""
        self.status_messages.append("========================================")
        try:
            if self.textLogger is not None:
                self.textLogger.setText("\n".join(self.status_messages))

                # Auto-scroll to the bottom
                scrollbar = self.textLogger.verticalScrollBar()
                scrollbar.setValue(scrollbar.maximum())

            if self.textLogger2 is not None:
                self.textLogger2.setText("\n".join(self.status_messages))

                # Auto-scroll to the bottom
                scrollbar = self.textLogger2.verticalScrollBar()
                scrollbar.setValue(scrollbar.maximum())
        except:
            # textLogger doesn't exist, just continue without updating it
            pass

    def update_status(self, message, level="info"):
        """Updates the status label and logs to QGIS log."""
        # Add timestamp and format the message
        timestamp = datetime.now().strftime("%H:%M:%S")
        formatted_message = f"{level.upper()}: {message}"
        formatted_message_with_timestamp = f"[{timestamp}] {formatted_message}"

        # Check for duplicate: identical level and message (ignoring timestamp)

        if formatted_message not in self._cached_messages:
            self._cached_messages.append(formatted_message)
            self.status_messages.append(formatted_message_with_timestamp)

            # Only update the textLogger if it exists
            try:
                if self.textLogger is not None:
                    self.textLogger.setText("\n".join(self.status_messages))

                    # Auto-scroll to the bottom
                    scrollbar = self.textLogger.verticalScrollBar()
                    scrollbar.setValue(scrollbar.maximum())
                if self.textLogger2 is not None:
                    self.textLogger2.setText("\n".join(self.status_messages))

                    # Auto-scroll to the bottom
                    scrollbar = self.textLogger2.verticalScrollBar()
                    scrollbar.setValue(scrollbar.maximum())
            except:
                # textLogger doesn't exist, just continue without updating it
                pass

    def closeEvent(self, event):
        """Ensure the thread is stopped when the dialog is closed."""
        try:
            # Stop token validation timer
            self.token_timer.stop()

            if self.thread and self.thread.isRunning():
                self.worker.stop()
                self.thread.quit()
                self.thread.wait()  # Wait for the thread to finish

            # Stop jobs monitoring
            if self.jobs_thread and self.jobs_thread.isRunning():
                self.jobs_worker.stop()
                self.jobs_thread.quit()
                self.jobs_thread.wait()
        except:
            pass

        event.accept()

    def cleanup_thread(self):
        """
        Cleans up thread and worker references after the thread has finished.
        This slot is connected to the thread's finished signal.
        """
        # Re-enable the button so the user can start another job
        self.requestPushButton.setEnabled(True)

        # Set the Python references to None
        self.thread = None
        self.worker = None

    def cleanup_temp_dirs(self):
        """
        This function is called when QGIS is about to quit.
        It safely removes all temporary directories created during the session.
        """
        try:
            self.update_status(
                f"Cleaning up {len(self.temp_dirs_to_clean)} temporary directories",
                "info",
            )
            for dir_path in self.temp_dirs_to_clean:
                try:
                    # shutil.rmtree can remove a directory and all its contents
                    shutil.rmtree(dir_path)
                except Exception as e:
                    # Log an error but don't prevent QGIS from closing
                    print(f"Could not remove temporary directory {dir_path}")
                    self.update_status(
                        f"Warning: Could not remove temp dir at location {dir_path}",
                        "warning",
                    )

            self.temp_dirs_to_clean.clear()
        except Exception as e:
            # Log an error but don't prevent QGIS from closing
            print(f"Could not remove temporary directory {dir_path}")
            self.update_status(
                f"Warning: Could not remove temp dir at location {dir_path}", "warning"
            )

        self.temp_dirs_to_clean.clear()

    def validate_form_request(self):
        """Validates the form and enables/disables the request button accordingly"""
        # Check if all required fields are filled
        start_date = self.startDateLineEdit.text().strip()
        end_date = self.endDateLineEdit.text().strip()
        selected_layer = self.polygonLayerComboBox.currentLayer()

        # Basic validation: all fields must be present
        if not start_date or not end_date or not selected_layer:
            self.requestPushButton.setEnabled(False)
            return

        # Validate date format and range
        try:
            start_parsed = parse_date(start_date)
            end_parsed = parse_date(end_date)

            if start_parsed is None or end_parsed is None:
                self.requestPushButton.setEnabled(False)
                return

            if start_parsed and end_parsed and start_parsed > end_parsed:
                self.requestPushButton.setEnabled(False)
                return

        except Exception:
            self.requestPushButton.setEnabled(False)
            return

        # All validations passed, enable the button
        self.requestPushButton.setEnabled(True)

    def _validate_polygon_layer(self, selected_layer):
        """Validate that the selected layer is a valid polygon layer with features"""
        if not isinstance(selected_layer, QgsVectorLayer):
            return False

        if selected_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False

        # Check if layer has features
        feature_count = selected_layer.featureCount()
        if feature_count == 0:
            return False

        return True

    def validate_form_from_layer(self):
        """Validates the form and enables/disables the request button accordingly"""
        selected_layer = self.rasterLayerComboBox.currentLayer()
        image_type = self.imageTypeComboBox.currentText()
        requested_layer = self.requestedLayerComboBox.currentText()

        # Check if all required fields are filled
        if not selected_layer or not image_type or not requested_layer:
            self.requestFilePushButton.setEnabled(False)
            return

        # Additional validation can be added here if needed
        self.requestFilePushButton.setEnabled(True)

    def update_requested_layer_options(self):
        """Updates the requestedLayerComboBox options based on imageTypeComboBox selection"""
        image_type = self.imageTypeComboBox.currentText()

        # Clear current options
        self.requestedLayerComboBox.clear()

        # Disable the combo box if no image type is selected
        if not image_type:
            self.requestedLayerComboBox.setEnabled(False)
            return

        # Enable the combo box
        self.requestedLayerComboBox.setEnabled(True)

        # Set options based on image type
        if image_type == "Sentinel-2 image":
            self.requestedLayerComboBox.addItems(
                ["Burned area delineation", "Burn Severity estimation"]
            )
        elif image_type == "Sentinel-1 image":
            self.requestedLayerComboBox.addItems(["Waterbody delineation"])
        else:
            # For other image types, show all options
            self.requestedLayerComboBox.addItems(
                [
                    "Burned area delineation",
                    "Burn Severity estimation",
                    "Active Flames and Smoke detection",
                    "Waterbody delineation",
                    "Sentinel-1 image",
                    "Sentinel-2 image",
                ]
            )

    def check_token_validity(self):
        """Check if the current token is still valid and handle expiration"""
        if not self.access_token:
            return

        if not self.token_manager.check_and_handle_expiration():
            # Token is expired, perform automatic logout
            self.perform_logout()
            self.update_status("Session expired. Please login again.", "warning")

    def perform_logout(self):
        """Perform automatic logout when token expires"""
        # Stop token validation timer
        self.token_timer.stop()

        # Clear authentication data
        self.access_token = None
        self.username = None
        self.password = None
        self.token_manager.clear_token()

        # Stop jobs monitoring
        if self.jobs_thread and self.jobs_thread.isRunning():
            self.jobs_worker.stop()
            self.jobs_thread.quit()
            self.jobs_thread.wait()

        # Disable all tabs except login
        self.tabWidget.setTabEnabled(1, False)
        self.tabWidget.setTabEnabled(2, False)
        self.tabWidget.setTabEnabled(3, False)

        # Switch to login tab
        self.tabWidget.setCurrentIndex(0)

        # Update login status
        self.loginInfoLabel.setText("Please login again.")
        self.loginPushButton.setEnabled(True)
        self.logoutButton.setEnabled(False)

        # Clear jobs table
        if hasattr(self, "jobsTableWidget"):
            self.jobsTableWidget.setRowCount(0)

    def on_aoi_method_changed(self):
        """Handle changes in AOI method selection (draw rectangle vs select polygon)"""
        if self.drawRectangleRadioButton.isChecked():
            # Show drawing controls, hide polygon layer combo box
            self.show_drawing_controls()
            self.polygonLayerComboBox.setVisible(False)
        else:
            # Hide drawing controls, show polygon layer combo box
            self.hide_drawing_controls()
            self.polygonLayerComboBox.setVisible(True)

        # Re-validate the form
        self.validate_form_request()

    def show_drawing_controls(self):
        """Show the drawing controls"""
        # Create a simple widget with draw/clear buttons
        if self.bboxWidget is None:
            from PyQt5.QtWidgets import (
                QWidget,
                QVBoxLayout,
                QHBoxLayout,
                QPushButton,
                QLabel,
            )

            self.bboxWidget = QWidget()
            layout = QVBoxLayout(self.bboxWidget)

            # Instructions
            instructions = QLabel("Click 'Draw Rectangle' to draw on the map")
            instructions.setWordWrap(True)
            layout.addWidget(instructions)

            # Button layout
            button_layout = QHBoxLayout()

            self.drawButton = QPushButton("Draw Rectangle")
            self.drawButton.clicked.connect(self.start_drawing)
            button_layout.addWidget(self.drawButton)

            self.clearButton = QPushButton("Clear Rectangle")
            self.clearButton.clicked.connect(self.clear_drawing)
            self.clearButton.setEnabled(False)
            button_layout.addWidget(self.clearButton)

            layout.addLayout(button_layout)

            # Status label
            self.statusLabel = QLabel("No rectangle drawn")
            layout.addWidget(self.statusLabel)

            # Insert the widget into the layout
            self.aoiMethodLayout.insertWidget(2, self.bboxWidget)

        if self.bboxWidget:
            self.bboxWidget.setVisible(True)

    def hide_drawing_controls(self):
        """Hide the drawing controls"""
        if self.bboxWidget:
            self.bboxWidget.setVisible(False)

        # Deactivate drawing tool if active
        if self.rectangleMapTool:

            iface.mapCanvas().unsetMapTool(self.rectangleMapTool)
            self.rectangleMapTool = None

    def start_drawing(self):
        """Start drawing mode"""

        if not iface:
            self.statusLabel.setText("Error: QGIS interface not available")
            return

        # Create and set the map tool
        self.rectangleMapTool = RectangleMapTool(iface.mapCanvas(), self)
        iface.mapCanvas().setMapTool(self.rectangleMapTool)

        self.statusLabel.setText("Click and drag on the map to draw rectangle...")

    def clear_drawing(self):
        """Clear the drawn rectangle"""
        if self.rectangleMapTool:
            self.rectangleMapTool.clear_rectangle()

        self.current_bbox = None
        self.statusLabel.setText("No rectangle drawn")
        self.clearButton.setEnabled(False)

        # Re-validate the form
        self.validate_form_request()

    def set_bbox_from_draw(self, minx, miny, maxx, maxy):
        """Called by RectangleMapTool when a rectangle is drawn"""
        self.current_bbox = (minx, miny, maxx, maxy)

        # Update UI
        self.drawButton.setText("Draw New Rectangle")
        self.clearButton.setEnabled(True)
        self.statusLabel.setText(
            f"Rectangle drawn: {minx:.6f}, {miny:.6f} to {maxx:.6f}, {maxy:.6f}"
        )

        # Deactivate map tool

        iface.mapCanvas().unsetMapTool(self.rectangleMapTool)
        self.rectangleMapTool = None

        # Re-validate the form
        self.validate_form_request()
