# -*- coding: utf-8 -*-
"""
/***************************************************************************
  ErmesQGISDialog
                                 A QGIS plugin
 Integration of ERMES model in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gaetano Chiriaco - Links Foundation
        email                : gaetano.chiriaco@linksfoundation.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import json
import os
import requests
from shapely.wkt import loads as wkt_loads
from shapely.geometry import mapping
import shutil
import tempfile
import zipfile
import time
from datetime import datetime

from qgis.core import (
    QgsRasterLayer,
    QgsProject,
    QgsMessageLog,
    Qgis,
    QgsGeometry,
    QgsVectorLayer,
    QgsApplication,
)
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from qgis.PyQt.QtCore import QObject, QThread, pyqtSignal, QDateTime


def parse_date(date: str) -> str:
    """If a date string is set it parses it into a format YYYY-MM-DD. In case parsing fails None is returned.

    :param date: A string describing a date
    :return: A string in a format YYYY-MM-DD, an empty string, or None
    """
    if date == "":
        return date
    try:
        return datetime.fromisoformat(date).isoformat()
    except ValueError:
        return None


class MainWorker(QObject):

    # FLAGS
    # Signals when Worker is finished, triggers clean-up and closes thread
    finished = pyqtSignal()
    # Signals when the layer is ready to be downloaded on Datalake
    layer_ready = pyqtSignal(str)
    # Used for INFO logging
    status_updated = pyqtSignal(str)
    # Used for ERROR logging
    error = pyqtSignal(str)

    def __init__(
        self,
        api_base_url: str,
        username: str,
        password: str,
        job_id: int,
    ):
        super().__init__()
        self.api_base_url = api_base_url
        self.username = username
        self.password = password
        self.job_id = job_id
        self.access_token = None
        self.is_running = True

    def _authenticate(self):
        """
        Authenticates with the API and gets an access token.

        :returns: A dictionary containing the Authorization header with the Bearer token.
        :raises HTTPError: If the authentication request fails.
        """
        if self.access_token:
            return {"Authorization": f"Bearer {self.access_token}"}

        auth_url = f"{self.api_base_url}/auth/login"
        data = {
            "username": self.username,
            "password": self.password,
        }

        response = requests.post(auth_url, data=data)
        response.raise_for_status()

        token_data = response.json()
        self.access_token = token_data["access_token"]
        return {"Authorization": f"Bearer {self.access_token}"}

    def _get_job_status(self):
        """
        Gets the current status of the job.

        :returns: The job status response as a dictionary.
        :raises HTTPError: If the request fails.
        """
        headers = self._authenticate()
        status_url = f"{self.api_base_url}/jobs/{self.job_id}"

        response = requests.get(status_url, headers=headers)
        response.raise_for_status()

        return response.json()

    def _download_resource(self):
        """
        Downloads the resource for the current job using the /retrieve/{job_id} endpoint
        and saves it to a temporary cache path.

        :return: The local cache path where the downloaded resource is saved.
        :raises HTTPError: If the HTTP request to the URL fails.
        """
        retrieve_url = f"{self.api_base_url}/retrieve/{self.job_id}"
        self.status_updated.emit(f"Downloading from {retrieve_url}")
        headers = self._authenticate()

        # Make the request to the retrieve endpoint
        with requests.get(retrieve_url, headers=headers, stream=True) as response:
            response.raise_for_status()
            # Try to get filename from Content-Disposition header, else fallback to job_id.zip
            content_disp = response.headers.get("Content-Disposition", "")
            filename = None
            if "filename=" in content_disp:
                filename = content_disp.split("filename=")[-1].strip('"; ')
            if not filename:
                # fallback: try to get from URL or use job_id.zip
                filename = f"{self.job_id}.zip"

            cache_dir = f"./tmp/{self.job_id}"
            os.makedirs(cache_dir, exist_ok=True)
            cache_path = os.path.join(cache_dir, filename)

            with open(cache_path, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)

        return cache_path

    def run(self):
        """
        Start polling the job status from the API.

        This method will run indefinitely until the job is completed or an exception is raised.
        When the method finishes, the `finished` signal will be emitted.

        :raises Exception: If an exception occurs while polling.
        """
        try:
            self.status_updated.emit(f"Worker: Starting to monitor job {self.job_id}")

            while self.is_running:
                try:
                    job_status = self._get_job_status()
                    status = job_status["status"]
                    result = job_status["result"]
                    status_code = job_status["status_code"]

                    if status == "end":
                        # Job completed successfully
                        if job_status.get("resource_url"):
                            local_path = self._download_resource()
                            self.status_updated.emit(
                                f"Downloaded resource to {local_path}"
                            )
                            self.layer_ready.emit(local_path)
                        else:
                            self.error.emit(
                                "Job completed but no resource URL provided"
                            )
                        break
                    elif status == "error":
                        # Job failed
                        if (
                            status_code == 404
                        ):  # Minor hack for error given on missing images (will fix in pipeline)
                            self.status_updated.emit(f"Job Warning: {result}")
                            time.sleep(5)
                        else:
                            self.error.emit(f"Job Error: {status_code} - {result}")
                            break
                    elif status in ["pending", "start", "update"]:
                        # Job is still running, wait before checking again
                        self.status_updated.emit(
                            f"Job {self.job_id} status: {status} - {result} "
                        )
                        time.sleep(5)  # Poll every 5 seconds
                    else:
                        self.error.emit(f"Unknown job status: {status}")
                        break

                except requests.exceptions.RequestException as e:
                    self.error.emit(f"API request error: {e}")
                    break

        except Exception as e:
            self.error.emit(f"Worker Error: {e}")
        finally:
            self.finished.emit()

    def stop(self):
        """Stops the worker. Called when the plugin is closed."""
        self.status_updated.emit("Worker: Stopping...")
        self.is_running = False


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")
)


class ErmesQGISDialog(QtWidgets.QDockWidget, FORM_CLASS):
    def __init__(self, parent=None):

        super(ErmesQGISDialog, self).__init__(parent)
        self.setupUi(self)

        # Setup for temporary directory management
        self.temp_dirs_to_clean = []
        QgsApplication.instance().aboutToQuit.connect(self.cleanup_temp_dirs)

        # Worker utils
        self.thread = None
        self.worker = None

        # Setup for API
        plugin_dir = os.path.dirname(__file__)
        self.config_path = os.path.join(plugin_dir, "certs/config.json")
        with open(self.config_path) as f:
            self.config = json.load(f)
        self.active_time = None
        self.api_base_url = self.config["api_base_url"]
        self.username = None  # Will be set when user logs in
        self.password = None  # Will be set when user logs in
        self.access_token = None  # Will be set after successful login

        # Available pipelines
        self.pipeline_map = {
            "Burned area delineation": "fire_burned_area_delineation",
            "Burn Severity estimation": "fire_burned_area_severity_estimation",
            "Active Flames and Smoke detection": "fire_active_flames_and_smoke_detection",
            "Waterbody delineation": "flood_post_waterbody_delineation",
            "Sentinel-2 image": "fire_satellite_image_sentinel_2",
            "Sentinel-1 image": "flood_satellite_image_sentinel_1",
        }

        # UI: Disable Request tab until login is successful
        # Assumes self.tabWidget is the QTabWidget containing the tabs
        # and that tab 0 is Login, tab 1 is Request
        self.tabWidget.setTabEnabled(1, False)

        # Connect UI signals to methods
        # Login
        self.loginPushButton.clicked.connect(self.login)
        # Request
        self.startDateLineEdit.mousePressEvent = lambda _: self.move_calendar(
            "start_date"
        )
        self.endDateLineEdit.mousePressEvent = lambda _: self.move_calendar("end_date")
        self.startDateLineEdit.editingFinished.connect(self.update_dates)
        self.endDateLineEdit.editingFinished.connect(self.update_dates)
        self.calendarWidget.clicked.connect(self.add_calendar_date)

        self.requestPushButton.clicked.connect(self.send_request)

    def move_calendar(self, active):
        """Moves calendar between the "start time" and "end time" line edit fields"""
        if active == "start_date":
            self.calendarSpacer.hide()
        else:
            self.calendarSpacer.show()
        self.active_time = active

    def update_dates(self):
        new_start_time = parse_date(self.startDateLineEdit.text())
        new_end_time = parse_date(self.endDateLineEdit.text())

        if new_start_time is None or new_end_time is None:
            self.update_status("Error: Invalid date format.", "error")
        elif new_start_time and new_end_time and new_start_time > new_end_time:
            self.update_status("Error: Start date must be before end date.", "error")
        else:
            self.startDateLineEdit.setText(new_start_time)
            self.endDateLineEdit.setText(new_end_time)

    def add_calendar_date(self):
        """Handles selected calendar date"""
        calendar_time = str(self.calendarWidget.selectedDate().toPyDate())

        if self.active_time == "start_date":
            self.startDateLineEdit.setText(calendar_time)
        else:
            self.endDateLineEdit.setText(calendar_time)

    def login(self, *_):
        """
        Handles user login. Reads username and password from the UI,
        sends them to the API, and if successful, enables the Request tab.
        """
        username = (
            self.usernameLineEdit.text().strip()
            if hasattr(self, "usernameLineEdit")
            else ""
        )
        password = (
            self.passwordLineEdit.text().strip()
            if hasattr(self, "passwordLineEdit")
            else ""
        )

        if not username or not password:
            self.loginInfoLabel.setText("Please enter both username and password.")
            return

        self.loginPushButton.setEnabled(False)
        self.loginInfoLabel.setText("Logging in...")

        try:
            auth_url = f"{self.api_base_url}/auth/login"
            auth_data = {
                "username": username,
                "password": password,
            }
            response = requests.post(auth_url, data=auth_data)
            response.raise_for_status()
            token_data = response.json()
            self.access_token = token_data.get("access_token")
            if not self.access_token:
                self.loginInfoLabel.setText("Login failed: No token received.")
                self.loginPushButton.setEnabled(True)
                return

            # Save credentials for later use
            self.username = username
            self.password = password

            self.loginInfoLabel.setText("Login Successful ✅")
            # Enable the Request tab
            self.tabWidget.setTabEnabled(1, True)
            # Optionally, switch to the Request tab automatically
            self.tabWidget.setCurrentIndex(1)
        except Exception as e:
            self.loginInfoLabel.setText(f"Login failed: {e}")
            self.loginPushButton.setEnabled(True)

    def send_request(self):
        """
        Sends a request to the API with the selected parameters.

        This function collects and validates the user inputs, constructs a message containing
        the selected polygon layer's geometry, the chosen pipeline, and the time range. It
        then sends this message to the API.

        The process includes:

        - Validating the selected polygon layer and its features.
        - Constructing a unified geometry from all features in the layer.
        - Converting the geometry to WKT format and loading it as a Shapely polygon.
        - Constructing a message dictionary with the pipeline, geometry, and time range.
        - Publishing the message to the API.

        If any error occurs during this process, it updates the status with an error message.

        :raises Exception: If an error occurs during message sending or connection setup.
        """

        # Check if logged in
        if not self.access_token:
            self.update_status("Error: Please login before making a request.", "error")
            return

        # Retrieve user inputs
        selected_layer = self.mMapLayerComboBox.currentLayer()
        pipeline_text = self.layerTypeComboBox.currentText()
        start_dt = self.startDateLineEdit.text()
        end_dt = self.endDateLineEdit.text()

        # Input validation
        if not isinstance(selected_layer, QgsVectorLayer):
            self.update_status("Error: Please select a valid polygon layer.", "error")
            return

        all_geoms = [feature.geometry() for feature in selected_layer.getFeatures()]
        if not all_geoms:
            self.update_status("Error: The selected layer has no features.", "error")
            return

        unified_qgs_geom = QgsGeometry.unaryUnion(all_geoms)
        if unified_qgs_geom.isEmpty():
            self.update_status(
                "Error: Could not create a valid geometry from the layer.", "error"
            )
            return

        wkt_geometry = unified_qgs_geom.asWkt()
        shapely_polygon = wkt_loads(wkt_geometry)

        if not all([selected_layer]):
            self.update_status("Error: All fields are required to send.", "error")
            return

        # Start Processing
        try:
            self.update_status("Sending request to API...")

            # Use the saved access token for authentication
            headers = {"Authorization": f"Bearer {self.access_token}"}

            # Create job request
            job_url = f"{self.api_base_url}/jobs/create"
            job_data = {
                "datatype_id": self.pipeline_map[pipeline_text],
                "geometry": mapping(shapely_polygon),
                "start_date": start_dt,
                "end_date": end_dt,
            }

            job_response = requests.post(job_url, json=job_data, headers=headers)
            job_response.raise_for_status()

            job_result = job_response.json()
            job_id = job_result["id"]

            self.update_status(f"Job created with ID: {job_id}", "info")

            # Start monitoring the job
            self.start_listening(job_id)

        except Exception as e:
            self.update_status(f"Error sending request: {e}", "error")

    def start_listening(self, job_id):
        """Set up the worker and thread to start monitoring the job."""
        if self.thread is not None and self.thread.isRunning():
            self.update_status("Already monitoring a job.", "warning")
            return

        # Create a QThread
        self.thread = QThread()
        # Create a worker
        self.worker = MainWorker(
            api_base_url=self.api_base_url,
            username=self.username,
            password=self.password,
            job_id=job_id,
        )

        # Move worker to the thread
        self.worker.moveToThread(self.thread)

        # Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        # Connect the thread's finished signal to our cleanup method
        self.thread.finished.connect(self.cleanup_thread)

        self.worker.layer_ready.connect(self.load_layer)
        self.worker.status_updated.connect(self.update_status)
        self.worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.thread.start()

        # Disable button
        self.requestPushButton.setEnabled(False)
        self.update_status(f"Started monitoring job {job_id}...", "info")

    def load_layer(self, file_path):
        """Loads the downloaded file into QGIS. This runs on the main thread."""
        self.update_status(
            f"Processing downloaded file: {os.path.basename(file_path)}", "info"
        )
        layer_name = os.path.splitext(os.path.basename(file_path))[0]

        # --- HANDLE ZIP ARCHIVES ---
        if file_path.lower().endswith(".zip"):
            self.handle_zip_file(file_path, layer_name)
        # --- HANDLE SINGLE TIF/TIFF FILES ---
        elif file_path.lower().endswith((".tif", ".tiff")):
            self.handle_single_tif(file_path, layer_name)
            # --- HANDLE UNSUPPORTED FILES ---
        else:
            self.update_status(
                f"Warning: File type not supported for auto-loading: {file_path}",
                "warning",
            )

    def handle_single_tif(self, file_path, layer_name):
        """Loads a single TIF file as a QGIS layer."""
        self.update_status(f"Loading raster layer: {layer_name}", "info")
        layer = QgsRasterLayer(file_path, layer_name)

        if not layer.isValid():
            self.update_status(
                f"Error: Failed to load raster layer {layer_name}", "error"
            )
            return

        QgsProject.instance().addMapLayer(layer)
        self.update_status(f"Successfully loaded {layer_name}", "success")

    def handle_zip_file(self, zip_path, group_name):
        """
        Unzips an archive and loads all contained .tif files into a new layer group.
        """
        # Use a temporary directory that is automatically cleaned up

        extract_dir = tempfile.mkdtemp(prefix="qgis_ermes_")
        self.temp_dirs_to_clean.append(extract_dir)

        self.update_status(
            f"Unzipping '{os.path.basename(zip_path)}' to a temporary location...",
            "info",
        )

        try:
            # Extract the zip file
            with zipfile.ZipFile(zip_path, "r") as zip_ref:
                zip_ref.extractall(extract_dir)
            try:
                os.remove(zip_path)
                self.update_status(
                    f"Removed original archive: {os.path.basename(zip_path)}", "info"
                )
            except OSError as e:
                self.update_status(
                    f"Warning: Could not remove original zip file {zip_path}: {e}",
                    "warning",
                )
        except zipfile.BadZipFile:
            self.update_status(
                f"Error: '{os.path.basename(zip_path)}' is not a valid zip file.",
                "error",
            )
            return
        except Exception as e:
            self.update_status(f"Error extracting zip file: {e}", "error")
            return

        # Scan the extracted directory for .tif files
        tiff_files = []
        for root_dir, _, files in os.walk(extract_dir):
            for file in files:
                if file.lower().endswith((".tif", ".tiff")):
                    tiff_files.append(os.path.join(root_dir, file))

        if not tiff_files:
            self.update_status(
                f"No .tif files were found inside '{os.path.basename(zip_path)}'.",
                "warning",
            )
            return

        # Get the project instance and the root of the layer tree
        project = QgsProject.instance()
        root = project.layerTreeRoot()

        # Create a new group in the layer tree. The group_name comes from layer_name.
        group = root.addGroup(group_name)

        loaded_count = 0
        for tiff_path in tiff_files:
            # Use the tif's own filename as the layer name
            individual_layer_name = os.path.splitext(os.path.basename(tiff_path))[0]

            layer = QgsRasterLayer(tiff_path, individual_layer_name)
            if not layer.isValid():
                self.update_status(
                    f"Skipping invalid raster: {individual_layer_name}", "warning"
                )
                continue

            # Add the layer to the project's internal registry, but NOT to the legend yet (False).
            # This prevents it from appearing at the top level.
            project.addMapLayer(layer, False)

            # Now, add the layer to our newly created group.
            group.addLayer(layer)
            loaded_count += 1

        self.update_status(
            f"Successfully loaded {loaded_count} layer(s) into group '{group_name}'.",
            "success",
        )

    def update_status(self, message, level="info"):
        """Updates the status label and logs to QGIS log."""
        self.textLogger.setText(message)
        log_level = Qgis.Info
        if level == "error":
            log_level = Qgis.Critical
        elif level == "warning":
            log_level = Qgis.Warning
        elif level == "success":
            log_level = Qgis.Success

        QgsMessageLog.logMessage(message, "Ermes_API", level=log_level)

    def closeEvent(self, event):
        """Ensure the thread is stopped when the dialog is closed."""
        self.update_status("Closing...")
        if self.thread and self.thread.isRunning():
            self.worker.stop()
            self.thread.quit()
            self.thread.wait()  # Wait for the thread to finish
        event.accept()

    def cleanup_thread(self):
        """
        Cleans up thread and worker references after the thread has finished.
        This slot is connected to the thread's finished signal.
        """
        self.update_status("Job monitoring stopped.", "info")

        # Re-enable the button so the user can start another job
        self.requestPushButton.setEnabled(True)

        # Set the Python references to None
        self.thread = None
        self.worker = None

    def cleanup_temp_dirs(self):
        """
        This function is called when QGIS is about to quit.
        It safely removes all temporary directories created during the session.
        """
        try:
            self.update_status(
                f"Cleaning up {len(self.temp_dirs_to_clean)} temporary directories...",
                "info",
            )
            for dir_path in self.temp_dirs_to_clean:
                try:
                    # shutil.rmtree can remove a directory and all its contents
                    shutil.rmtree(dir_path)
                except Exception as e:
                    # Log an error but don't prevent QGIS from closing
                    print(f"Could not remove temporary directory {dir_path}: {e}")
                    self.update_status(
                        f"Warning: Could not remove temp dir {dir_path}", "warning"
                    )

            self.temp_dirs_to_clean.clear()
        except Exception as e:
            # Log an error but don't prevent QGIS from closing
            print(f"Could not remove temporary directory {dir_path}: {e}")
            self.update_status(
                f"Warning: Could not remove temp dir {dir_path}", "warning"
            )

        self.temp_dirs_to_clean.clear()
