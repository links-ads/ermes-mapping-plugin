# -*- coding: utf-8 -*-
"""
/***************************************************************************
  ErmesQGISDialog
                                 A QGIS plugin
 Integration of ERMES model in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gaetano Chiriaco - Links Foundation
        email                : gaetano.chiriaco@linksfoundation.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import os
import requests
import shutil
import tempfile
import zipfile
from datetime import datetime
import json
import base64
from qgis.core import (
    QgsRasterLayer,
    QgsProject,
    QgsGeometry,
    QgsVectorLayer,
    QgsApplication,
    QgsWkbTypes,
    QgsRectangle,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsTask,
)
from qgis.utils import iface
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QTableWidgetItem, QHeaderView, QDockWidget, QListWidgetItem, QLabel
from qgis.PyQt.QtCore import QThread, QTimer
from PyQt5.QtGui import QPixmap, QIcon
from qgis.core import QgsMapLayerProxyModel

# Store job data in the row for later use
from PyQt5.QtCore import Qt

# Import the workers from their new modules
from .workers.job import JobsWorker
from .workers.main import MainWorker
from .workers.file_upload_task import FileUploadTask
from .workers.token_manager import TokenManager

# Import the BoundingBoxWidget
from .widgets.bbox_widget import RectangleMapTool

# Import utility functions
from .utils.date_utils import parse_date
from .utils.config_loader import ConfigLoader
from .utils.geometry_utils import (
    transform_geometry_to_epsg4326,
    create_geometry_from_rectangle,
    unify_layer_geometries,
    geometry_to_json,
)

import warnings

warnings.filterwarnings("ignore")
base_path = os.path.dirname(os.path.abspath(__file__))
thumbnail_image = os.path.join(base_path, "images", "title.png")


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")
)


class ErmesQGISDialog(QDockWidget):
    def __init__(self, parent=None):
        super(ErmesQGISDialog, self).__init__(parent)

        # Set dock widget properties
        self.setWindowTitle("ERMES for QGIS")
        self.setAllowedAreas(Qt.RightDockWidgetArea | Qt.LeftDockWidgetArea)
        self.setFeatures(
            QDockWidget.DockWidgetMovable
            | QDockWidget.DockWidgetFloatable
            | QDockWidget.DockWidgetClosable
        )

        # Load the UI file and set it as the widget for the dock
        ui_file = os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")

        # Create a widget to hold the UI content
        self.content_widget = QtWidgets.QWidget()
        uic.loadUi(ui_file, self.content_widget)

        # Set the content widget as the widget for the dock
        self.setWidget(self.content_widget)

        # Create a helper to access UI elements more easily
        self.ui = self.content_widget

        # Initialize the plugin
        self._initialize_plugin()

    def __getattr__(self, name):
        """Redirect attribute access to UI elements"""
        try:
            return getattr(self.ui, name)
        except AttributeError:
            raise AttributeError(
                f"'{self.__class__.__name__}' object has no attribute '{name}'"
            )

    def _initialize_plugin(self):
        """Initialize plugin-specific data and settings"""
        # Setup for temporary directory management
        self.temp_dirs_to_clean = []
        QgsApplication.instance().aboutToQuit.connect(self.cleanup_temp_dirs)

        # Worker utils
        self.thread = None
        self.worker = None

        # Jobs tab worker utils
        self.jobs_thread = None
        self.jobs_worker = None
        self.jobs_timer = None

        # Initialize tab state - disable all tabs except login since no token yet
        self.tabWidget.setTabEnabled(1, False)  # Request
        self.tabWidget.setTabEnabled(2, False)  # From Layer
        self.tabWidget.setTabEnabled(3, False)  # Jobs
        self.tabWidget.setCurrentIndex(0)  # Switch to Login tab

        # Load configuration
        self.config = ConfigLoader()

        # Start Token validation timer
        self.token_timer = QTimer()
        self.token_timer.timeout.connect(self.check_token_validity)
        self.token_timer.setInterval(self.config.token_validation_interval_ms)

        # Initialize plugin data
        self._initialize_plugin_data()

        # Initialize Token Manager
        self.token_manager = TokenManager(self.api_base_url, self.config)

        # Set up the ERMES image in the login tab
        self.setup_ermes_image()
        # Setup jobs table
        self.setup_jobs_table()
        # Setup layer type list widget
        self.setup_layer_type_list()
        
        # Connect UI signals to methods
        # Login
        self.loginPushButton.clicked.connect(self.login)
        self.logoutButton.clicked.connect(self.perform_logout)
        # Request
        self.startDateLineEdit.mousePressEvent = lambda _: self.move_calendar(
            "start_date"
        )
        self.endDateLineEdit.mousePressEvent = lambda _: self.move_calendar("end_date")
        self.startDateLineEdit.editingFinished.connect(self.update_dates)
        self.endDateLineEdit.editingFinished.connect(self.update_dates)
        self.calendarWidget.clicked.connect(self.add_calendar_date)

        # Connect validation signals
        self.startDateLineEdit.textChanged.connect(self.validate_form_request)
        self.endDateLineEdit.textChanged.connect(self.validate_form_request)
        self.polygonLayerComboBox.layerChanged.connect(self.validate_form_request)

        # Connect radio button signals for AOI method selection
        self.drawRectangleRadioButton.toggled.connect(self.on_aoi_method_changed)
        self.selectPolygonRadioButton.toggled.connect(self.on_aoi_method_changed)
        self.useMapExtentRadioButton.toggled.connect(self.on_aoi_method_changed)

        self.requestPushButton.clicked.connect(self.send_request)

        # From Layer
        self.rasterLayerComboBox.layerChanged.connect(self.validate_form_from_layer)
        self.imageTypeComboBox.currentTextChanged.connect(
            self.update_requested_layer_options
        )
        self.imageTypeComboBox.currentTextChanged.connect(self.validate_form_from_layer)
        self.requestedLayerComboBox.currentTextChanged.connect(
            self.validate_form_from_layer
        )
        self.requestFilePushButton.clicked.connect(self.send_request_from_layer)

        # Jobs tab
        self.downloadJobButton.clicked.connect(self.download_selected_jobs)
        self.refreshJobsButton.clicked.connect(self.refresh_jobs_table)

        # Initial validation
        self.validate_form_request()
        self.validate_form_from_layer()

        # Initialize requested layer options
        self.update_requested_layer_options()

        # Initialize AOI method
        self.on_aoi_method_changed()
        
        # Load saved credentials if they exist
        self.load_credentials()
        
        # Setup loading indicators for the "Get Layer" buttons
        self.setup_loading_indicators()

    def _initialize_plugin_data(self):
        """Initialize plugin-specific data and settings"""
        # Setup for API
        self.active_time = None
        
        # Load configuration values
        self.api_base_url = self.config.api_base_url
        self.pipeline_info = self.config.get_pipeline_info()
        self.pipeline_map = self.config.get_pipeline_map()
        self.image_type_map = self.config.image_type_map
        self.style_root = self.config.style_root
        self.style_map = self.config.style_map
        
        self.username = None  # Will be set when user logs in
        self.password = None  # Will be set when user logs in
        self.access_token = None  # Will be set after successful login
        

        # Initialize layer type list widget (needed since it doesn't work when doing it in the UI file)
        self.polygonLayerComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.rasterLayerComboBox.setFilters(QgsMapLayerProxyModel.RasterLayer)

        # Initialize data for BoundingBoxWidget
        self.bboxWidget = None
        self.rectangleMapTool = None
        self.current_bbox = None  # Store current bounding box coordinates

        # Initialize status messages list
        self.status_messages = []
        self._cached_messages = []

        self.credentials_path = os.path.join( os.path.dirname(__file__), self.config.credentials_file)

    # Credentials handling methods
    
    def save_credentials(self, username, password):
        """Save credentials to a file with basic encoding"""
        try:
        
            # Encode credentials (basic obfuscation, not secure encryption)
            encoded_username = base64.b64encode(username.encode()).decode()
            encoded_password = base64.b64encode(password.encode()).decode()
            
            credentials = {
                "username": encoded_username,
                "password": encoded_password
            }
            
            with open(self.credentials_path, 'w') as f:
                json.dump(credentials, f)
                
        except Exception as e:
            # Don't fail if we can't save credentials, just log it
            print(f"Could not save credentials: {e}")
    
    def load_credentials(self):
        """Load credentials from file if it exists"""
        try:
            if not os.path.exists(self.credentials_path):
                return
            
            with open(self.credentials_path, 'r') as f:
                credentials = json.load(f)
            
            # Decode credentials
            username = base64.b64decode(credentials["username"].encode()).decode()
            password = base64.b64decode(credentials["password"].encode()).decode()
            
            # Set the credentials in the UI
            if hasattr(self, "usernameLineEdit"):
                self.usernameLineEdit.setText(username)
            if hasattr(self, "passwordLineEdit"):
                self.passwordLineEdit.setText(password)
                
        except Exception as e:
            # Don't fail if we can't load credentials, just continue
            print(f"Could not load credentials: {e}")
    
    def clear_saved_credentials(self):
        """Delete the saved credentials file"""
        try:
            if os.path.exists(self.credentials_path):
                os.remove(self.credentials_path)
        except Exception as e:
            print(f"Could not delete credentials file: {e}")

    # UI setup methods
    
    def setup_jobs_table(self):
        """Setup the jobs table with appropriate columns"""
        # Assuming the table is named jobsTableWidget
        if hasattr(self, "jobsTableWidget"):
            self.jobsTableWidget.setColumnCount(7)
            self.jobsTableWidget.setHorizontalHeaderLabels(
                [
                    "ID",
                    "Pipeline",
                    "Status",
                    "Status Message",
                    "Created",
                    "Start Date",
                    "End Date",
                ]
            )

            # Set column widths
            header = self.jobsTableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)  # ID
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Pipeline
            header.setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Status
            header.setSectionResizeMode(
                3, QHeaderView.ResizeToContents
            )  # Status Message
            header.setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Created
            header.setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Start Date
            header.setSectionResizeMode(6, QHeaderView.ResizeToContents)  # End Date

            # Hide the vertical header (row numbers)
            self.jobsTableWidget.verticalHeader().setVisible(False)

            # Enable selection
            self.jobsTableWidget.setSelectionBehavior(
                QtWidgets.QAbstractItemView.SelectRows
            )
            self.jobsTableWidget.setSelectionMode(
                QtWidgets.QAbstractItemView.MultiSelection
            )

    def setup_layer_type_list(self):
        """Setup the layer type list widget with images and descriptions"""
        if hasattr(self, "layerTypeListWidget"):
            self.layerTypeListWidget.clear()
            
            # Get the base path for images (plugin root directory)
            base_path = os.path.dirname(__file__)
            
            for layer_name, layer_data in self.pipeline_info.items():
                # Create list widget item
                item = QListWidgetItem()
                
                # Set the icon (look in plugin root directory)
                icon_path = os.path.join(base_path, self.config.images_directory, layer_data["image"])
                if os.path.exists(icon_path):
                    item.setIcon(QIcon(icon_path))
                else:
                    # Use default QGIS icon as placeholder
                    item.setIcon(QIcon(":/images/themes/default/mIconRaster.svg"))
                
                # Set the text with name and description
                item.setText(f"{layer_name}\n{layer_data['description']}")
                
                # Store the layer name as user data for easy retrieval
                item.setData(Qt.UserRole, layer_name)
                
                # Set tooltip
                item.setToolTip(f"{layer_name}: {layer_data['description']}")
                
                # Add item to list
                self.layerTypeListWidget.addItem(item)
            
            # Select the first item (Sentinel-1 image) by default
            if self.layerTypeListWidget.count() > 0:
                self.layerTypeListWidget.setCurrentRow(0)
            
            # Connect selection change signal
            self.layerTypeListWidget.itemSelectionChanged.connect(self.validate_form_request)

    def start_jobs_monitoring(self):
        """Start monitoring jobs from the API"""
        try:
            if self.jobs_thread is not None and self.jobs_thread.isRunning():
                self.update_status("Already monitoring jobs.", "warning")
                return
        except Exception as e:
            # If the jobs_thread is not initialized, create it
            pass

        # Create a QThread for jobs monitoring
        self.jobs_thread = QThread()
        # Create a jobs worker
        self.jobs_worker = JobsWorker(
            api_base_url=self.api_base_url, access_token=self.access_token, config=self.config
        )

        # Move worker to the thread
        self.jobs_worker.moveToThread(self.jobs_thread)

        # Connect signals and slots
        self.jobs_thread.started.connect(self.jobs_worker.run)
        self.jobs_worker.finished.connect(self.jobs_thread.quit)
        self.jobs_worker.finished.connect(self.jobs_worker.deleteLater)
        self.jobs_thread.finished.connect(self.jobs_thread.deleteLater)

        # Connect worker signals
        self.jobs_worker.jobs_updated.connect(self.update_jobs_table)
        self.jobs_worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.jobs_thread.start()

    def update_jobs_table(self, jobs):
        """Update the jobs table with the latest jobs data"""
        if not hasattr(self, "jobsTableWidget"):
            return

        self.jobsTableWidget.setRowCount(0)  # Clear existing rows

        for job in jobs:
            # Show all jobs regardless of status
            row = self.jobsTableWidget.rowCount()
            self.jobsTableWidget.insertRow(row)

            datatype_id = job.get("body", {}).get("datatype_id", "")
            start_date = job.get("body", {}).get("start_date", "")
            end_date = job.get("body", {}).get("end_date", "")

            # Add job data to table
            self.jobsTableWidget.setItem(
                row, 0, QTableWidgetItem(str(job.get("id", "")))
            )
            self.jobsTableWidget.setItem(row, 1, QTableWidgetItem(datatype_id))
            self.jobsTableWidget.setItem(
                row, 2, QTableWidgetItem(job.get("status", ""))
            )
            self.jobsTableWidget.setItem(
                row, 3, QTableWidgetItem(job.get("result", ""))
            )
            self.jobsTableWidget.setItem(
                row, 4, QTableWidgetItem(job.get("created_at", ""))
            )
            self.jobsTableWidget.setItem(row, 5, QTableWidgetItem(start_date))
            self.jobsTableWidget.setItem(row, 6, QTableWidgetItem(end_date))

            self.jobsTableWidget.item(row, 0).setData(Qt.UserRole, job)

    def download_selected_jobs(self):
        """Download and load selected jobs from the Jobs Table into QGIS"""
        selected_rows = set()
        for item in self.jobsTableWidget.selectedItems():
            selected_rows.add(item.row())

        if not selected_rows:
            self.update_status("No jobs selected for download.", "warning")
            return

        # Filter jobs that can be downloaded (end status with resource_url)
        downloadable_jobs = []
        non_downloadable_jobs = []

        for row in selected_rows:
            try:
                # Get job data from the table
                job_item = self.jobsTableWidget.item(row, 0)
                if job_item:
                    job_data = job_item.data(Qt.UserRole)
                    job_id = job_data.get("id")
                    job_status = job_data.get("status")
                    resource_url = job_data.get("resource_url")

                    if job_status == "end" and resource_url:
                        downloadable_jobs.append((row, job_id))
                    else:
                        non_downloadable_jobs.append(job_id)

            except Exception as e:
                self.update_status(
                    f"Internal error processing job from row {row}", "error"
                )

        # Show warning for non-downloadable jobs
        if non_downloadable_jobs:
            self.update_status(
                f"Warning: Jobs {non_downloadable_jobs} cannot be downloaded (not completed or no resource available).",
                "warning",
            )

        if not downloadable_jobs:
            self.update_status("No downloadable jobs selected.", "warning")
            return

        self.update_status(
            f"Downloading {len(downloadable_jobs)} selected job(s)...", "info"
        )

        for row, job_id in downloadable_jobs:
            try:
                # Download the job resource
                self.download_job_resource(job_id)
            except Exception as e:
                self.update_status(
                    f"Internal error while downloading resource for job {job_id}", "error"
                )

    def download_job_resource(self, job_id):
        """Download a specific job resource and load it into QGIS"""

        try:
            # First, get the job details to retrieve the datatype_id
            job_url = f"{self.api_base_url}{self.config.api_endpoints['jobs_detail'].format(job_id=job_id)}"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            job_response = requests.get(job_url, headers=headers)
            job_response.raise_for_status()
            job_data = job_response.json()

            # Extract datatype_id from the job data
            datatype_id = job_data.get("body", {}).get("datatype_id", None)

            retrieve_url = f"{self.api_base_url}{self.config.api_endpoints['retrieve'].format(job_id=job_id)}"

            self.update_status(f"Downloading job {job_id}...", "info")

            with requests.get(retrieve_url, headers=headers, stream=True) as response:
                response.raise_for_status()

                # Get filename from Content-Disposition header
                content_disp = response.headers.get("Content-Disposition", "")
                filename = None
                if "filename=" in content_disp:
                    filename = content_disp.split("filename=")[-1].strip('"; ')
                if not filename:
                    filename = f"{job_id}.zip"

                # Use a temporary directory to save the file
                with tempfile.TemporaryDirectory(
                    prefix=f"{self.config.temp_dir_prefix}{job_id}_"
                ) as temp_dir:
                    cache_path = os.path.join(temp_dir, filename)

                    with open(cache_path, "wb") as f:
                        for chunk in response.iter_content(chunk_size=self.config.processing_chunk_size):
                            if chunk:
                                f.write(chunk)

                    # Load the downloaded file into QGIS with datatype_id
                    self.load_layer(cache_path, datatype_id)
                # Temporary directory and file are automatically cleaned up here

        except Exception as e:
            self.update_status(f"Internal error downloading job {job_id}", "error")


    def refresh_jobs_table(self):
        """Refreshes the jobs table by re-fetching jobs from the API."""
        if not self.access_token:
            self.update_status("Error: Please login before refreshing jobs.", "error")
            return

        # Check token validity before making request
        if not self.token_manager.check_and_handle_expiration():
            self.perform_logout()
            self.update_status("Session expired. Please login again.", "warning")
            return

        self.update_status("Refreshing jobs table...", "info")

        try:
            # Call the API directly to get jobs
            headers = {"Authorization": f"Bearer {self.access_token}"}
            jobs_url = f"{self.api_base_url}{self.config.api_endpoints['jobs_list']}"

            response = requests.get(jobs_url, headers=headers)
            response.raise_for_status()

            jobs = response.json()["jobs"]
            self.update_jobs_table(jobs)
            self.update_status(
                f"Successfully refreshed jobs table with {len(jobs)} jobs.", "success"
            )

        except requests.exceptions.RequestException as e:
            self.update_status(f"Failed to fetch jobs to refresh jobs table", "error")
        except Exception as e:
            self.update_status(f"Internal error refreshing jobs table", "error")

    def move_calendar(self, active):
        """Moves calendar between the "start time" and "end time" line edit fields"""
        if active == "start_date":
            self.calendarSpacer.hide()
        else:
            self.calendarSpacer.show()
        self.active_time = active

    def update_dates(self):
        new_start_time = parse_date(self.startDateLineEdit.text())
        new_end_time = parse_date(self.endDateLineEdit.text())

        if new_start_time is None or new_end_time is None:
            self.update_status("Invalid date format.", "error")
        elif new_start_time and new_end_time and new_start_time > new_end_time:
            self.update_status("Start date must be before end date.", "warning")
        elif new_start_time and datetime.fromisoformat(
            new_start_time
        ) > datetime.now().replace(tzinfo=None):
            self.update_status("Start date must be before the current date.", "warning")
        elif new_end_time and datetime.fromisoformat(
            new_end_time
        ) > datetime.now().replace(tzinfo=None):
            self.update_status("End date must be before the current date.", "warning")
        else:
            self.startDateLineEdit.setText(new_start_time)
            self.endDateLineEdit.setText(new_end_time)

    def add_calendar_date(self):
        """Handles selected calendar date"""
        calendar_time = str(self.calendarWidget.selectedDate().toPyDate())

        if self.active_time == "start_date":
            self.startDateLineEdit.setText(calendar_time)
        else:
            self.endDateLineEdit.setText(calendar_time)

    def login(self, *_):
        """
        Handles user login. Reads username and password from the UI,
        sends them to the API, and if successful, enables the Request and Jobs tabs.
        """
        username = (
            self.usernameLineEdit.text().strip()
            if hasattr(self, "usernameLineEdit")
            else ""
        )
        password = (
            self.passwordLineEdit.text().strip()
            if hasattr(self, "passwordLineEdit")
            else ""
        )

        if not username or not password:
            self.loginInfoLabel.setText("Please enter both username and password.")
            return

        self.loginPushButton.setEnabled(False)
        self.loginInfoLabel.setText("Logging in...")

        try:
            auth_url = f"{self.api_base_url}{self.config.api_endpoints['login']}"
            auth_data = {
                "username": username,
                "password": password,
            }
            response = requests.post(auth_url, data=auth_data)
            response.raise_for_status()
            token_data = response.json()
            self.access_token = token_data.get("access_token")
            if not self.access_token:
                self.loginInfoLabel.setText("Login failed: No token received.")
                self.loginPushButton.setEnabled(True)
                return

            # Save credentials for later use
            self.username = username
            self.password = password
            
            # Save credentials to file for auto-login
            self.save_credentials(username, password)

            # Set token in token manager
            self.token_manager.set_token(self.access_token)

            self.loginInfoLabel.setText("Login Successful ✅")
            # Enable the Request and Jobs tabs
            self.tabWidget.setTabEnabled(1, True)
            self.tabWidget.setTabEnabled(2, True)
            self.tabWidget.setTabEnabled(3, True)
            # Optionally, switch to the Request tab automatically
            self.tabWidget.setCurrentIndex(1)

            self.logoutButton.setEnabled(True)

            # Start token validation timer
            self.token_timer.start()

            # Start monitoring jobs
            self.start_jobs_monitoring()

        except requests.HTTPError as http_err:
            if http_err.response is not None:
                status_code = http_err.response.status_code
                try:
                    error_json = http_err.response.json()
                    error_detail = error_json.get("detail", str(error_json))
                except Exception:
                    error_detail = http_err.response.text

                if status_code == 401:
                    self.loginInfoLabel.setText(
                        "Login failed: Unauthorized (401). Please check your username and password."
                    )
                elif status_code == 403:
                    self.loginInfoLabel.setText(
                        "Login failed: Forbidden (403). You do not have access."
                    )
                elif status_code == 500:
                    self.loginInfoLabel.setText(
                        "Login failed: Server error (500). Please try again later."
                    )
                else:
                    self.loginInfoLabel.setText(
                        f"Login failed ({status_code}): {error_detail}"
                    )
            else:
                self.loginInfoLabel.setText("Login failed: HTTP error occurred.")
            self.loginPushButton.setEnabled(True)
        except requests.ConnectionError:
            self.loginInfoLabel.setText(
                "Login failed: Unable to connect to server. Please check your network connection."
            )
            self.loginPushButton.setEnabled(True)
        except requests.Timeout:
            self.loginInfoLabel.setText(
                "Login failed: Request timed out. Please try again."
            )
            self.loginPushButton.setEnabled(True)
        except Exception as e:
            self.loginInfoLabel.setText(f"Login failed: Internal error {e}")
            self.loginPushButton.setEnabled(True)

    def get_aoi_geometry(self):
        """
        Get the Area of Interest (AOI) geometry based on the selected method.
        
        Returns the geometry in EPSG:4326 projection.
        
        :return: Tuple (QgsGeometry, error_message) - Returns (None, error_msg) on error
        """
        if self.drawRectangleRadioButton.isChecked():
            return self._get_geometry_from_drawn_rectangle()
        elif self.selectPolygonRadioButton.isChecked():
            return self._get_geometry_from_polygon_layer()
        else:  # useMapExtentRadioButton is checked
            return self._get_geometry_from_map_extent()
    
    def _get_geometry_from_drawn_rectangle(self):
        """Get geometry from drawn rectangle."""
        if not self.current_bbox:
            return None, "Please draw a rectangle first."
        
        # Create geometry from bbox coordinates (already in EPSG:4326 from bbox_widget)
        minx, miny, maxx, maxy = self.current_bbox
        geometry = create_geometry_from_rectangle(minx, miny, maxx, maxy)
        
        return geometry, None
    
    def _get_geometry_from_polygon_layer(self):
        """Get geometry from selected polygon layer."""
        selected_layer = self.polygonLayerComboBox.currentLayer()
        
        if not isinstance(selected_layer, QgsVectorLayer):
            return None, "Please select a valid polygon layer."
        
        # Unify all geometries from the layer
        unified_geom, error = unify_layer_geometries(selected_layer)
        if error:
            return None, error
        
        # Transform geometry to EPSG:4326 if needed
        layer_crs = selected_layer.crs()
        transformed_geom, was_transformed, error = transform_geometry_to_epsg4326(
            unified_geom, layer_crs
        )
        
        if error:
            return None, f"Error transforming geometry: {error}"
        
        if was_transformed:
            self.update_status(
                f"Transformed geometry from {layer_crs.authid()} to EPSG:4326",
                "info",
            )
        
        return transformed_geom, None
    
    def _get_geometry_from_map_extent(self):
        """Get geometry from current map extent."""
        canvas = iface.mapCanvas()
        extent = canvas.extent()
        canvas_crs = canvas.mapSettings().destinationCrs()
        
        # Create geometry from extent
        geometry = QgsGeometry.fromRect(extent)
        
        # Transform to EPSG:4326 if needed
        transformed_geom, was_transformed, error = transform_geometry_to_epsg4326(
            geometry, canvas_crs
        )
        
        if error:
            return None, f"Error transforming map extent: {error}"
        
        if was_transformed:
            self.update_status(
                f"Using current map extent (transformed from {canvas_crs.authid()} to EPSG:4326)",
                "info",
            )
        else:
            self.update_status("Using current map extent as area of interest", "info")
        
        return transformed_geom, None

    def send_request(self):
        """
        Sends a request to the API with the selected parameters.

        This function collects and validates the user inputs, constructs a message containing
        the selected geometry, the chosen pipeline, and the time range. It then sends this 
        message to the API.

        If any error occurs during this process, it updates the status with an error message.

        :raises Exception: If an error occurs during message sending or connection setup.
        """

        # Check if logged in
        if not self.access_token:
            self.update_status("Error: Please login before making a request.", "error")
            return

        # Check token validity before making request
        if not self.token_manager.check_and_handle_expiration():
            self.perform_logout()
            self.update_status("Session expired. Please login again.", "warning")
            return

        # Retrieve user inputs
        # Get selected layer from list widget
        selected_items = self.layerTypeListWidget.selectedItems()
        if not selected_items:
            self.update_status("Error: Please select a layer type.", "error")
            return
        
        pipeline_text = selected_items[0].data(Qt.UserRole)
        start_dt = self.startDateLineEdit.text()
        end_dt = self.endDateLineEdit.text()

        # Get AOI geometry
        unified_qgs_geom, error = self.get_aoi_geometry()
        if error:
            self.update_status(f"Error: {error}", "error")
            return

        geometry_str = geometry_to_json(unified_qgs_geom)

        try:
            geometry = json.loads(geometry_str)
        except Exception as e:
            self.update_status(f"Error parsing geometry JSON: {e}", "error")
            return

        # Start Processing
        try:
            self.update_status("Sending request to API...")

            # Use the saved access token for authentication
            headers = {"Authorization": f"Bearer {self.access_token}"}

            # Create job request
            job_url = f"{self.api_base_url}{self.config.api_endpoints['jobs_create']}"
            job_data = {
                "datatype_id": self.pipeline_map[pipeline_text],
                "geometry": geometry,
                "start_date": start_dt,
                "end_date": end_dt,
            }

            job_response = requests.post(job_url, json=job_data, headers=headers)
            job_response.raise_for_status()

            job_result = job_response.json()
            job_id = job_result["id"]
            self.add_log_separator()
            self.update_status(f"Job created with ID: {job_id}", "info")

            # Start monitoring the job
            self.start_listening(job_id)

        except Exception as e:
            self.update_status(f"Error sending request: {e}", "error")

    def send_request_from_layer(self):
        """Sends a request to the API with the selected parameters, uploading the raster file asynchronously."""
        if not self.access_token:
            self.update_status("Error: Please login before making a request.", "error")
            return

        # Retrieve user inputs
        self.update_status("Retrieving user layers...")
        selected_layer = self.rasterLayerComboBox.currentLayer()
        image_type = self.imageTypeComboBox.currentText()
        requested_layer = self.requestedLayerComboBox.currentText()

        # Input validation
        if not isinstance(selected_layer, QgsRasterLayer):
            self.update_status("Error: Please select a valid raster layer.", "error")
            return

        # Get the file path of the raster layer
        file_path = selected_layer.source()
        if not file_path or not file_path.lower().endswith((".tif", ".tiff")):
            self.update_status(
                "Error: The selected raster layer must be a TIFF file.", "error"
            )
            return

        # Start asynchronous file upload using QgsTask
        self.start_file_upload_task(
            file_path,
            self.pipeline_map[requested_layer],
            self.image_type_map[image_type],
        )

    def start_file_upload_task(self, file_path: str, datatype_id: str, image_type: str):
        """Start a QgsTask for uploading the file asynchronously."""
        try:
            filename = os.path.basename(file_path)
            description = f"Uploading {filename} to ERMES API"

            # Validate file exists
            if not os.path.exists(file_path):
                self.update_status(f"Error: File {filename} does not exist", "error")
                return

            # Create the upload task
            upload_task = FileUploadTask(
                description=description,
                file_path=file_path,
                datatype_id=datatype_id,
                image_type=image_type,
                api_base_url=self.api_base_url,
                access_token=self.access_token,
                dialog_ref=self,
                config=self.config,
            )

            # Add the task to QGIS task manager
            task_manager = QgsApplication.taskManager()
            task_manager.addTask(upload_task)

            # Connect signals for safe communication
            upload_task.status_update.connect(self.update_status)
            upload_task.upload_completed.connect(self.on_file_upload_completed)
            upload_task.upload_failed.connect(self.on_file_upload_failed)

            # Disable button during upload and show loading indicator
            self.requestFilePushButton.setEnabled(False)
            self.fromLayerLoadingLabel.setVisible(True)
            self.update_status(f"Job created and started for: {filename}", "info")

            # Check task status after a short delay
            from PyQt5.QtCore import QTimer

            def check_task_status():
                try:
                    status = upload_task.status()
                    self.update_status(f"Task status: {status}", "info")
                    if status == QgsTask.Queued:
                        self.update_status("Task is queued but not running yet", "info")
                    elif status == QgsTask.Running:
                        self.update_status("Task is running", "info")
                    elif status == QgsTask.Complete:
                        self.update_status("Task completed", "info")
                    elif status == QgsTask.Terminated:
                        self.update_status("Task terminated", "warning")
                    else:
                        self.update_status(f"Unknown task status: {status}", "warning")
                except Exception:
                    pass

            # Check status after 2 seconds
            QTimer.singleShot(2000, check_task_status)

            # Also check after 5 seconds
            QTimer.singleShot(5000, check_task_status)

        except Exception as e:
            self.update_status(f"Error starting file upload: {e}", "error")
            self.requestFilePushButton.setEnabled(True)
            self.fromLayerLoadingLabel.setVisible(False)

    def on_file_upload_completed(self, temp_file_path: str, datatype_id: str):
        """Handle successful file upload completion"""
        try:
            self.update_status(
                "File upload completed successfully. Loading result into QGIS...",
                "success",
            )
            self.load_layer(temp_file_path, datatype_id)
            self.add_log_separator()
            self.requestFilePushButton.setEnabled(True)
            self.fromLayerLoadingLabel.setVisible(False)
        except Exception as e:
            self.update_status(f"Error loading uploaded file result: {e}", "error")
            self.requestFilePushButton.setEnabled(True)
            self.fromLayerLoadingLabel.setVisible(False)

    def on_file_upload_failed(self, error_message: str):
        """Handle file upload failure"""
        self.update_status(error_message, "error")
        self.requestFilePushButton.setEnabled(True)
        self.fromLayerLoadingLabel.setVisible(False)

    def start_listening(self, job_id):
        """Set up the worker and thread to start monitoring the job."""
        if self.thread is not None and self.thread.isRunning():
            self.update_status("Already monitoring a job.", "warning")
            return

        # Create a QThread
        self.thread = QThread()
        # Create a worker
        self.worker = MainWorker(
            api_base_url=self.api_base_url,
            username=self.username,
            password=self.password,
            job_id=job_id,
            config=self.config,
        )

        # Move worker to the thread
        self.worker.moveToThread(self.thread)

        # Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        # Connect the thread's finished signal to our cleanup method
        self.thread.finished.connect(self.cleanup_thread)

        self.worker.layer_ready.connect(self.load_layer)
        self.worker.status_updated.connect(self.update_status)
        self.worker.log_separator.connect(self.add_log_separator)
        self.worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.thread.start()

        # Disable button and show loading indicator
        self.requestPushButton.setEnabled(False)
        self.requestLoadingLabel.setVisible(True)
        self.update_status(f"Started monitoring job {job_id}...", "info")

    def load_layer(self, file_path, datatype_id=None):
        """Loads the downloaded file into QGIS. This runs on the main thread."""
        self.update_status(
            f"Loading retrieved layer: {os.path.basename(file_path)}", "info"
        )
        layer_name = os.path.splitext(os.path.basename(file_path))[0]

        # --- HANDLE ZIP ARCHIVES ---
        if file_path.lower().endswith(".zip"):
            self.handle_zip_file(file_path, layer_name, datatype_id)
        # --- HANDLE SINGLE TIF/TIFF FILES ---
        elif file_path.lower().endswith((".tif", ".tiff")):
            self.handle_single_tif(file_path, layer_name, datatype_id)
        # --- HANDLE UNSUPPORTED FILES ---
        else:
            self.update_status(
                f"Warning: File type not supported for auto-loading: {file_path}",
                "warning",
            )

    def handle_single_tif(self, file_path, layer_name, datatype_id=None):
        """Loads a single TIF file as a QGIS layer and applies a style."""
        self.update_status(f"Loading raster layer: {layer_name}", "info")
        layer = QgsRasterLayer(file_path, layer_name)

        if not layer.isValid():
            self.update_status(
                f"Error: Failed to load raster layer {layer_name}", "error"
            )
            return

        # Apply style if datatype_id is available and in the style map
        if datatype_id and datatype_id in self.style_map:
            style_filename = self.style_map[datatype_id]
            style_path = os.path.join(
                os.path.dirname(__file__), self.style_root, style_filename
            )

            if os.path.exists(style_path):
                loaded = layer.loadNamedStyle(style_path)
                layer.triggerRepaint()
                if loaded[0]:
                    self.update_status(f"Applied style from {style_filename}", "info")
                else:
                    self.update_status(
                        f"Applied style from {style_filename} (QGIS returned warning: {loaded[1]})",
                        "info",
                    )
            else:
                self.update_status(
                    f"Warning: Style file not found: {style_path}", "warning"
                )
        else:
            self.update_status(
                "No style applied - datatype_id not available or not in style map.",
                "info",
            )

        QgsProject.instance().addMapLayer(layer, addToLegend=True)
        # Move the layer to position 0 (top of the layer tree)
        root = QgsProject.instance().layerTreeRoot()
        node = root.findLayer(layer.id())
        if node is not None:
            root.insertChildNode(0, node.clone())
            root.removeChildNode(node)
        self.update_status(f"Successfully loaded {layer_name}", "success")
        self.add_log_separator()

    def handle_zip_file(self, zip_path, group_name, datatype_id=None):
        """
        Unzips an archive and loads all contained .tif files into a new layer group, applying a style to each.
        """
        # Use a temporary directory that is automatically cleaned up
        extract_dir = tempfile.mkdtemp(prefix=self.config.temp_dir_prefix)
        self.temp_dirs_to_clean.append(extract_dir)

        try:
            # Extract the zip file
            with zipfile.ZipFile(zip_path, "r") as zip_ref:
                zip_ref.extractall(extract_dir)
            try:
                os.remove(zip_path)
            except OSError as e:
                self.update_status(
                    f"Warning: Could not remove original zip file at location{zip_path}",
                    "warning",
                )
        except zipfile.BadZipFile:
            self.update_status(
                f"Error: '{os.path.basename(zip_path)}' is not a valid zip file",
                "error",
            )
            return
        except Exception as e:
            self.update_status(f"Error extracting zip file", "error")
            return

        # Scan the extracted directory for .tif files
        tiff_files = []
        for root_dir, _, files in os.walk(extract_dir):
            for file in files:
                if file.lower().endswith((".tif", ".tiff")):
                    tiff_files.append(os.path.join(root_dir, file))

        if not tiff_files:
            self.update_status(
                f"No .tif files were found inside '{os.path.basename(zip_path)}'",
                "warning",
            )
            return

        # Get the project instance and the root of the layer tree
        project = QgsProject.instance()
        root = project.layerTreeRoot()

        # Create a new group in the layer tree at position 0. The group_name comes from layer_name.
        group = root.insertGroup(0, group_name)

        # Get style path if datatype_id is available and in the style map
        style_path = None
        if datatype_id and datatype_id in self.style_map:
            style_filename = self.style_map[datatype_id]
            style_path = os.path.join(
                os.path.dirname(__file__), self.style_root, style_filename
            )

        loaded_count = 0
        for tiff_path in tiff_files:
            # Use the tif's own filename as the layer name
            individual_layer_name = os.path.splitext(os.path.basename(tiff_path))[0]

            layer = QgsRasterLayer(tiff_path, individual_layer_name)
            if not layer.isValid():
                self.update_status(
                    f"Skipping invalid raster: {individual_layer_name}",
                    "warning",
                )
                continue

            # Apply style if available
            if style_path and os.path.exists(style_path):
                loaded = layer.loadNamedStyle(style_path)
                if loaded[0]:
                    layer.triggerRepaint()
                    self.update_status(
                        f"Applied style to {individual_layer_name} from {os.path.basename(style_path)}",
                        "info",
                    )
                else:
                    pass
            else:
                if datatype_id and datatype_id in self.style_map:
                    self.update_status(
                        f"Style file not found for {individual_layer_name}, loading without style",
                        "warning",
                    )
                else:
                    self.update_status(
                        f"No style applied to {individual_layer_name} - datatype_id not available or not in style map",
                        "info",
                    )

            # Add the layer to the project's internal registry, but NOT to the legend yet (False).
            # This prevents it from appearing at the top level.
            project.addMapLayer(layer, False)

            # Now, add the layer to our newly created group.
            group.addLayer(layer)
            loaded_count += 1

        self.update_status(
            f"Successfully loaded {loaded_count} layer(s) into group '{group_name}'",
            "success",
        )
        self.add_log_separator()

    def add_log_separator(self):
        """Adds a separator to the log."""
        self.status_messages.append("========================================")
        try:
            if self.textLogger is not None:
                self.textLogger.setText("\n".join(self.status_messages))

                # Auto-scroll to the bottom
                scrollbar = self.textLogger.verticalScrollBar()
                scrollbar.setValue(scrollbar.maximum())

            if self.textLogger2 is not None:
                self.textLogger2.setText("\n".join(self.status_messages))

                # Auto-scroll to the bottom
                scrollbar = self.textLogger2.verticalScrollBar()
                scrollbar.setValue(scrollbar.maximum())
        except:
            # textLogger doesn't exist, just continue without updating it
            pass

    def update_status(self, message, level="info"):
        """Updates the status label and logs to QGIS log."""
        # Add timestamp and format the message
        timestamp = datetime.now().strftime("%H:%M:%S")
        formatted_message = f"{level.upper()}: {message}"
        formatted_message_with_timestamp = f"[{timestamp}] {formatted_message}"

        # Check for duplicate: identical level and message (ignoring timestamp)

        if formatted_message not in self._cached_messages:
            self._cached_messages.append(formatted_message)
            self.status_messages.append(formatted_message_with_timestamp)

            # Only update the textLogger if it exists
            try:
                if self.textLogger is not None:
                    self.textLogger.setText("\n".join(self.status_messages))

                    # Auto-scroll to the bottom
                    scrollbar = self.textLogger.verticalScrollBar()
                    scrollbar.setValue(scrollbar.maximum())
                if self.textLogger2 is not None:
                    self.textLogger2.setText("\n".join(self.status_messages))

                    # Auto-scroll to the bottom
                    scrollbar = self.textLogger2.verticalScrollBar()
                    scrollbar.setValue(scrollbar.maximum())
            except:
                # textLogger doesn't exist, just continue without updating it
                pass

    def closeEvent(self, event):
        """Ensure the thread is stopped when the dialog is closed."""
        try:
            # Stop token validation timer
            self.token_timer.stop()

            if self.thread and self.thread.isRunning():
                self.worker.stop()
                self.thread.quit()
                self.thread.wait()  # Wait for the thread to finish

            # Stop jobs monitoring
            if self.jobs_thread and self.jobs_thread.isRunning():
                self.jobs_worker.stop()
                self.jobs_thread.quit()
                self.jobs_thread.wait()
        except:
            pass

        event.accept()

    def cleanup_thread(self):
        """
        Cleans up thread and worker references after the thread has finished.
        This slot is connected to the thread's finished signal.
        """
        # Re-enable the button and hide loading indicator
        self.requestPushButton.setEnabled(True)
        self.requestLoadingLabel.setVisible(False)

        # Set the Python references to None
        self.thread = None
        self.worker = None

    def cleanup_temp_dirs(self):
        """
        This function is called when QGIS is about to quit.
        It safely removes all temporary directories created during the session.
        """
        try:
            self.update_status(
                f"Cleaning up {len(self.temp_dirs_to_clean)} temporary directories",
                "info",
            )
            for dir_path in self.temp_dirs_to_clean:
                try:
                    # shutil.rmtree can remove a directory and all its contents
                    shutil.rmtree(dir_path)
                except Exception as e:
                    # Log an error but don't prevent QGIS from closing
                    print(f"Could not remove temporary directory {dir_path}")
                    self.update_status(
                        f"Warning: Could not remove temp dir at location {dir_path}",
                        "warning",
                    )

            self.temp_dirs_to_clean.clear()
        except Exception as e:
            # Log an error but don't prevent QGIS from closing
            print(f"Could not remove temporary directory {dir_path}")
            self.update_status(
                f"Warning: Could not remove temp dir at location {dir_path}", "warning"
            )

        self.temp_dirs_to_clean.clear()

    def validate_form_request(self):
        """Validates the form and enables/disables the request button accordingly"""
        # Check if all required fields are filled
        start_date = self.startDateLineEdit.text().strip()
        end_date = self.endDateLineEdit.text().strip()
        
        # Check layer type selection
        selected_layer_type = self.layerTypeListWidget.selectedItems()
        if not selected_layer_type:
            self.requestPushButton.setEnabled(False)
            return
        
        # Check AOI method
        if self.drawRectangleRadioButton.isChecked():
            # For drawn rectangle, check if bbox exists
            if not self.current_bbox:
                self.requestPushButton.setEnabled(False)
                return
        elif self.selectPolygonRadioButton.isChecked():
            # For polygon layer, check if valid layer selected
            selected_layer = self.polygonLayerComboBox.currentLayer()
            if not selected_layer:
                self.requestPushButton.setEnabled(False)
                return
        # For map extent, no additional check needed - always available

        # Basic validation: all fields must be present
        if not start_date or not end_date:
            self.requestPushButton.setEnabled(False)
            return

        # Validate date format and range
        try:
            start_parsed = parse_date(start_date)
            end_parsed = parse_date(end_date)

            if start_parsed is None or end_parsed is None:
                self.requestPushButton.setEnabled(False)
                return

            if start_parsed and end_parsed and start_parsed > end_parsed:
                self.requestPushButton.setEnabled(False)
                return

        except Exception:
            self.requestPushButton.setEnabled(False)
            return

        # All validations passed, enable the button
        self.requestPushButton.setEnabled(True)

    def _validate_polygon_layer(self, selected_layer):
        """Validate that the selected layer is a valid polygon layer with features"""
        if not isinstance(selected_layer, QgsVectorLayer):
            return False

        if selected_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False

        # Check if layer has features
        feature_count = selected_layer.featureCount()
        if feature_count == 0:
            return False

        return True

    def validate_form_from_layer(self):
        """Validates the form and enables/disables the request button accordingly"""
        selected_layer = self.rasterLayerComboBox.currentLayer()
        image_type = self.imageTypeComboBox.currentText()
        requested_layer = self.requestedLayerComboBox.currentText()

        # Check if all required fields are filled
        if not selected_layer or not image_type or not requested_layer:
            self.requestFilePushButton.setEnabled(False)
            return

        # Additional validation can be added here if needed
        self.requestFilePushButton.setEnabled(True)

    def update_requested_layer_options(self):
        """Updates the requestedLayerComboBox options based on imageTypeComboBox selection"""
        image_type = self.imageTypeComboBox.currentText()

        # Clear current options
        self.requestedLayerComboBox.clear()

        # Disable the combo box if no image type is selected
        if not image_type:
            self.requestedLayerComboBox.setEnabled(False)
            return

        # Enable the combo box
        self.requestedLayerComboBox.setEnabled(True)

        # Set options based on image type
        if image_type == "Sentinel-2 image":
            self.requestedLayerComboBox.addItems(
                ["Burned area delineation", "Burn Severity estimation"]
            )
        elif image_type == "Sentinel-1 image":
            self.requestedLayerComboBox.addItems(
                ["Waterbody delineation", "Water depth estimation"]
            )
        else:
            # For other image types, show all options
            self.requestedLayerComboBox.addItems(
                [
                    "Burned area delineation",
                    "Burn Severity estimation",
                    "Active Flames and Smoke detection",
                    "Waterbody delineation",
                    "Sentinel-1 image",
                    "Sentinel-2 image",
                    "Water depth estimation",
                ]
            )

    def check_token_validity(self):
        """Check if the current token is still valid and handle expiration"""
        if not self.access_token:
            return

        if not self.token_manager.check_and_handle_expiration():
            # Token is expired, perform automatic logout
            self.perform_logout()
            self.update_status("Session expired. Please login again.", "warning")

    def perform_logout(self):
        """Perform automatic logout when token expires"""
        # Stop token validation timer
        self.token_timer.stop()

        # Clear authentication data
        self.access_token = None
        self.username = None
        self.password = None
        self.token_manager.clear_token()
        
        # Clear saved credentials file
        self.clear_saved_credentials()

        # Stop jobs monitoring
        if self.jobs_thread and self.jobs_thread.isRunning():
            self.jobs_worker.stop()
            self.jobs_thread.quit()
            self.jobs_thread.wait()
        # Disable all tabs except login
        self.tabWidget.setTabEnabled(1, False)
        self.tabWidget.setTabEnabled(2, False)
        self.tabWidget.setTabEnabled(3, False)

        # Switch to login tab
        self.tabWidget.setCurrentIndex(0)

        # Update login status
        self.loginInfoLabel.setText("Please login again.")
        self.loginPushButton.setEnabled(True)
        self.logoutButton.setEnabled(False)
        
        # Clear username and password fields
        if hasattr(self, "usernameLineEdit"):
            self.usernameLineEdit.clear()
        if hasattr(self, "passwordLineEdit"):
            self.passwordLineEdit.clear()

        # Clear jobs table
        if hasattr(self, "jobsTableWidget"):
            self.jobsTableWidget.setRowCount(0)

    def on_aoi_method_changed(self):
        """Handle changes in AOI method selection (draw rectangle vs select polygon vs map extent)"""
        if self.drawRectangleRadioButton.isChecked():
            # Show drawing controls, hide polygon layer combo box
            self.show_drawing_controls()
            self.polygonLayerComboBox.setVisible(False)
        elif self.selectPolygonRadioButton.isChecked():
            # Hide drawing controls, show polygon layer combo box
            self.hide_drawing_controls()
            self.polygonLayerComboBox.setVisible(True)
        else:  # useMapExtentRadioButton is checked
            # Hide both drawing controls and polygon layer combo box
            self.hide_drawing_controls()
            self.polygonLayerComboBox.setVisible(False)

        # Re-validate the form
        self.validate_form_request()

    def show_drawing_controls(self):
        """Show the drawing controls"""
        # Create a simple widget with draw/clear buttons
        if self.bboxWidget is None:
            from PyQt5.QtWidgets import (
                QWidget,
                QVBoxLayout,
                QHBoxLayout,
                QPushButton,
                QLabel,
            )

            self.bboxWidget = QWidget()
            layout = QVBoxLayout(self.bboxWidget)

            # Instructions
            instructions = QLabel("Click 'Draw Rectangle' to draw on the map")
            instructions.setWordWrap(True)
            layout.addWidget(instructions)

            # Button layout
            button_layout = QHBoxLayout()

            self.drawButton = QPushButton("Draw Rectangle")
            self.drawButton.clicked.connect(self.start_drawing)
            button_layout.addWidget(self.drawButton)

            self.clearButton = QPushButton("Clear Rectangle")
            self.clearButton.clicked.connect(self.clear_drawing)
            self.clearButton.setEnabled(False)
            button_layout.addWidget(self.clearButton)

            layout.addLayout(button_layout)

            # Status label
            self.statusLabel = QLabel("No rectangle drawn")
            layout.addWidget(self.statusLabel)

            # Insert the widget into the layout
            self.aoiMethodLayout.insertWidget(2, self.bboxWidget)

        if self.bboxWidget:
            self.bboxWidget.setVisible(True)

    def hide_drawing_controls(self):
        """Hide the drawing controls"""
        if self.bboxWidget:
            self.bboxWidget.setVisible(False)

        # Deactivate drawing tool if active
        if self.rectangleMapTool:

            iface.mapCanvas().unsetMapTool(self.rectangleMapTool)
            self.rectangleMapTool = None

    def start_drawing(self):
        """Start drawing mode"""

        if not iface:
            self.statusLabel.setText("Error: QGIS interface not available")
            return

        # Create and set the map tool
        self.rectangleMapTool = RectangleMapTool(iface.mapCanvas(), self)
        iface.mapCanvas().setMapTool(self.rectangleMapTool)

        self.statusLabel.setText("Click and drag on the map to draw rectangle...")

    def clear_drawing(self):
        """Clear the drawn rectangle"""
        if self.rectangleMapTool:
            self.rectangleMapTool.clear_rectangle()

        self.current_bbox = None
        self.statusLabel.setText("No rectangle drawn")
        self.clearButton.setEnabled(False)

        # Re-validate the form
        self.validate_form_request()

    def set_bbox_from_draw(self, minx, miny, maxx, maxy):
        """Called by RectangleMapTool when a rectangle is drawn"""
        self.current_bbox = (minx, miny, maxx, maxy)

        # Update UI
        self.drawButton.setText("Draw New Rectangle")
        self.clearButton.setEnabled(True)
        self.statusLabel.setText(
            f"Rectangle drawn: {minx:.6f}, {miny:.6f} to {maxx:.6f}, {maxy:.6f}"
        )

        # Deactivate map tool

        iface.mapCanvas().unsetMapTool(self.rectangleMapTool)
        self.rectangleMapTool = None

        # Re-validate the form
        self.validate_form_request()

    def setup_loading_indicators(self):
        """Setup loading indicators for the Get Layer buttons"""
        from PyQt5.QtWidgets import QHBoxLayout, QWidget
        
        # Create loading indicator for Request tab
        self.requestLoadingLabel = QLabel("⏳ Processing...")
        self.requestLoadingLabel.setStyleSheet("""
            QLabel {
                color: #1565C0;
                font-weight: bold;
                padding: 5px;
                background-color: #E3F2FD;
                border: 1px solid #2196F3;
                border-radius: 4px;
            }
        """)
        self.requestLoadingLabel.setVisible(False)
        
        # Get the grid layout from the Request tab
        request_grid = self.requestPushButton.parent().layout()
        if isinstance(request_grid, QtWidgets.QGridLayout):
            # Find the button's position
            button_index = request_grid.indexOf(self.requestPushButton)
            if button_index >= 0:
                row, col, rowspan, colspan = request_grid.getItemPosition(button_index)
                
                # Remove the button from the grid
                request_grid.removeWidget(self.requestPushButton)
                
                # Create a horizontal layout with the button and loading indicator
                request_h_layout = QHBoxLayout()
                request_h_layout.addWidget(self.requestPushButton)
                request_h_layout.addWidget(self.requestLoadingLabel)
                request_h_layout.addStretch()
                
                # Add the horizontal layout back to the grid at the same position
                request_grid.addLayout(request_h_layout, row, col)
        
        # Create loading indicator for From Layer tab
        self.fromLayerLoadingLabel = QLabel("⏳ Processing...")
        self.fromLayerLoadingLabel.setStyleSheet("""
            QLabel {
                color: #1565C0;
                font-weight: bold;
                padding: 5px;
                background-color: #E3F2FD;
                border: 1px solid #2196F3;
                border-radius: 4px;
            }
        """)
        self.fromLayerLoadingLabel.setVisible(False)
        
        # Get the grid layout from the From Layer tab
        from_layer_grid = self.requestFilePushButton.parent().layout()
        if isinstance(from_layer_grid, QtWidgets.QGridLayout):
            # Find the button's position
            button_index = from_layer_grid.indexOf(self.requestFilePushButton)
            if button_index >= 0:
                row, col, rowspan, colspan = from_layer_grid.getItemPosition(button_index)
                
                # Remove the button from the grid
                from_layer_grid.removeWidget(self.requestFilePushButton)
                
                # Create a horizontal layout with the button and loading indicator
                from_layer_h_layout = QHBoxLayout()
                from_layer_h_layout.addWidget(self.requestFilePushButton)
                from_layer_h_layout.addWidget(self.fromLayerLoadingLabel)
                from_layer_h_layout.addStretch()
                
                # Add the horizontal layout back to the grid at the same position
                from_layer_grid.addLayout(from_layer_h_layout, row, col)

    def setup_ermes_image(self):
        """Set up the ERMES image in the login tab welcome label"""
        try:
            # Path to the ERMES image
            ermes_image_path = os.path.join(base_path, "images", "ermes.png")

            if os.path.exists(ermes_image_path):
                # Load the image
                pixmap = QPixmap(ermes_image_path)

                # Scale the image to fit nicely in the welcome label
                # Get the label size and scale the image proportionally
                if hasattr(self, "welcomeLabel"):
                    label_size = self.welcomeLabel.size()
                    if label_size.width() > 0 and label_size.height() > 0:
                        # Scale the image to fit within the label, maintaining aspect ratio
                        scaled_pixmap = pixmap.scaled(
                            label_size.width() * 3,
                            label_size.height() * 3,
                            Qt.KeepAspectRatio,
                            Qt.SmoothTransformation,
                        )
                        self.welcomeLabel.setPixmap(scaled_pixmap)
                        self.welcomeLabel.setAlignment(Qt.AlignCenter)
                    else:
                        # If label size is not available yet, use the original image
                        self.welcomeLabel.setPixmap(pixmap)
                        self.welcomeLabel.setAlignment(Qt.AlignCenter)
        except Exception as e:
            self.update_status(f"Error loading ERMES image: {e}", "error")
