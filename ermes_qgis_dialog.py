# -*- coding: utf-8 -*-
"""
/***************************************************************************
  ErmesQGISDialog
                                 A QGIS plugin
 Integration of ERMES model in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gaetano Chiriaco - Links Foundation
        email                : gaetano.chiriaco@linksfoundation.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import os
import requests
from shapely.wkt import loads as wkt_loads
from shapely.geometry import mapping
import shutil
import tempfile
import zipfile
from datetime import datetime, timezone

from qgis.core import (
    QgsRasterLayer,
    QgsProject,
    QgsMessageLog,
    Qgis,
    QgsGeometry,
    QgsVectorLayer,
    QgsApplication,
    QgsWkbTypes,
)
from qgis.PyQt import uic, QtWidgets
from PyQt5.QtWidgets import QTableWidgetItem, QHeaderView
from qgis.PyQt.QtCore import QThread
from qgis.core import QgsMapLayerProxyModel

# Store job data in the row for later use
from PyQt5.QtCore import Qt

# Import the workers from their new modules
from .workers.job import JobsWorker
from .workers.main import MainWorker

import warnings

warnings.filterwarnings("ignore")


def parse_date(date: str) -> str:
    """If a date string is set it parses it into a format YYYY-MM-DD. In case parsing fails None is returned.

    :param date: A string describing a date
    :return: A string in a format YYYY-MM-DD, an empty string, or None
    """
    if date == "":
        return date
    try:
        return datetime.fromisoformat(date).isoformat()
    except ValueError:
        return None


FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "ermes_qgis_dialog_base.ui")
)


class ErmesQGISDialog(QtWidgets.QStackedWidget, FORM_CLASS):
    def __init__(self, parent=None):

        super(ErmesQGISDialog, self).__init__(parent)
        self.setupUi(self)

        # Setup for temporary directory management
        self.temp_dirs_to_clean = []
        QgsApplication.instance().aboutToQuit.connect(self.cleanup_temp_dirs)

        # Worker utils
        self.thread = None
        self.worker = None

        # Jobs tab worker utils
        self.jobs_thread = None
        self.jobs_worker = None
        self.jobs_timer = None

        # Setup for API
        self.active_time = None
        self.api_base_url = "https://loki.linksfoundation.com/ermes-plugin"
        self.username = None  # Will be set when user logs in
        self.password = None  # Will be set when user logs in
        self.access_token = None  # Will be set after successful login

        self.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        # Available pipelines
        self.pipeline_map = {
            "Burned area delineation": "fire_burned_area_delineation",
            "Burn Severity estimation": "fire_burned_area_severity_estimation",
            "Active Flames and Smoke detection": "fire_active_flames_and_smoke_detection",
            "Waterbody delineation": "flood_post_waterbody_delineation",
            "Sentinel-2 image": "fire_satellite_image_sentinel_2",
            "Sentinel-1 image": "flood_satellite_image_sentinel_1",
        }

        # Available styles
        self.style_root = "styles"
        self.style_map = {
            "fire_burned_area_delineation": "fire_burned_area_delineation.qml",
            "fire_burned_area_severity_estimation": "fire_burned_area_severity_estimation.qml",
            "fire_active_flames_and_smoke_detection": "fire_active_flames_and_smoke_detection.qml",
            "flood_post_waterbody_delineation": "flood_post_waterbody_delineation.qml",
            "fire_satellite_image_sentinel_2": "fire_satellite_image_sentinel_2.qml",
            "flood_satellite_image_sentinel_1": "flood_satellite_image_sentinel_1.qml",
        }

        # UI: Disable Request and Jobs tabs until login is successful
        # Assumes self.tabWidget is the QTabWidget containing the tabs
        # and that tab 0 is Login, tab 1 is Request, tab 2 is Jobs
        self.tabWidget.setTabEnabled(1, False)
        self.tabWidget.setTabEnabled(2, False)

        # Setup jobs table
        self.setup_jobs_table()

        # Initialize status messages list
        self.status_messages = []
        self._cached_messages = []

        # Connect UI signals to methods
        # Login
        self.loginPushButton.clicked.connect(self.login)
        # Request
        self.startDateLineEdit.mousePressEvent = lambda _: self.move_calendar(
            "start_date"
        )
        self.endDateLineEdit.mousePressEvent = lambda _: self.move_calendar("end_date")
        self.startDateLineEdit.editingFinished.connect(self.update_dates)
        self.endDateLineEdit.editingFinished.connect(self.update_dates)
        self.calendarWidget.clicked.connect(self.add_calendar_date)

        # Connect validation signals
        self.startDateLineEdit.textChanged.connect(self.validate_form)
        self.endDateLineEdit.textChanged.connect(self.validate_form)
        self.mMapLayerComboBox.layerChanged.connect(self.validate_form)

        self.requestPushButton.clicked.connect(self.send_request)

        # Jobs tab
        self.downloadJobButton.clicked.connect(self.download_selected_jobs)
        self.deleteJobButton.clicked.connect(self.delete_selected_jobs)
        self.refreshJobsButton.clicked.connect(self.refresh_jobs_table)

        # Initial validation
        self.validate_form()

    def setup_jobs_table(self):
        """Setup the jobs table with appropriate columns"""
        # Assuming the table is named jobsTableWidget
        if hasattr(self, "jobsTableWidget"):
            self.jobsTableWidget.setColumnCount(7)
            self.jobsTableWidget.setHorizontalHeaderLabels(
                [
                    "ID",
                    "Pipeline",
                    "Status",
                    "Status Message",
                    "Created",
                    "Start Date",
                    "End Date",
                ]
            )

            # Set column widths
            header = self.jobsTableWidget.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)  # ID
            header.setSectionResizeMode(1, QHeaderView.Stretch)  # Pipeline
            header.setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Status
            header.setSectionResizeMode(
                3, QHeaderView.ResizeToContents
            )  # Status Message
            header.setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Created
            header.setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Start Date
            header.setSectionResizeMode(6, QHeaderView.ResizeToContents)  # End Date

            # Enable selection
            self.jobsTableWidget.setSelectionBehavior(
                QtWidgets.QAbstractItemView.SelectRows
            )
            self.jobsTableWidget.setSelectionMode(
                QtWidgets.QAbstractItemView.MultiSelection
            )

    def start_jobs_monitoring(self):
        """Start monitoring jobs from the API"""
        if self.jobs_thread is not None and self.jobs_thread.isRunning():
            self.update_status("Already monitoring jobs.", "warning")
            return

        # Create a QThread for jobs monitoring
        self.jobs_thread = QThread()
        # Create a jobs worker
        self.jobs_worker = JobsWorker(
            api_base_url=self.api_base_url, access_token=self.access_token
        )

        # Move worker to the thread
        self.jobs_worker.moveToThread(self.jobs_thread)

        # Connect signals and slots
        self.jobs_thread.started.connect(self.jobs_worker.run)
        self.jobs_worker.finished.connect(self.jobs_thread.quit)
        self.jobs_worker.finished.connect(self.jobs_worker.deleteLater)
        self.jobs_thread.finished.connect(self.jobs_thread.deleteLater)

        # Connect worker signals
        self.jobs_worker.jobs_updated.connect(self.update_jobs_table)
        self.jobs_worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.jobs_thread.start()

    def update_jobs_table(self, jobs):
        """Update the jobs table with the latest jobs data"""
        if not hasattr(self, "jobsTableWidget"):
            return

        self.jobsTableWidget.setRowCount(0)  # Clear existing rows

        for job in jobs:
            # Show all jobs regardless of status
            row = self.jobsTableWidget.rowCount()
            self.jobsTableWidget.insertRow(row)

            datatype_id = job.get("body", {}).get("datatype_id", "")
            start_date = job.get("body", {}).get("start_date", "")
            end_date = job.get("body", {}).get("end_date", "")

            # Add job data to table
            self.jobsTableWidget.setItem(
                row, 0, QTableWidgetItem(str(job.get("id", "")))
            )
            self.jobsTableWidget.setItem(row, 1, QTableWidgetItem(datatype_id))
            self.jobsTableWidget.setItem(
                row, 2, QTableWidgetItem(job.get("status", ""))
            )
            self.jobsTableWidget.setItem(
                row, 3, QTableWidgetItem(job.get("result", ""))
            )
            self.jobsTableWidget.setItem(
                row, 4, QTableWidgetItem(job.get("created_at", ""))
            )
            self.jobsTableWidget.setItem(row, 5, QTableWidgetItem(start_date))
            self.jobsTableWidget.setItem(row, 6, QTableWidgetItem(end_date))

            self.jobsTableWidget.item(row, 0).setData(Qt.UserRole, job)

    def download_selected_jobs(self):
        """Download and load selected jobs into QGIS"""
        selected_rows = set()
        for item in self.jobsTableWidget.selectedItems():
            selected_rows.add(item.row())

        if not selected_rows:
            self.update_status("No jobs selected for download.", "warning")
            return

        # Filter jobs that can be downloaded (end status with resource_url)
        downloadable_jobs = []
        non_downloadable_jobs = []

        for row in selected_rows:
            try:
                # Get job data from the table
                job_item = self.jobsTableWidget.item(row, 0)
                if job_item:
                    job_data = job_item.data(Qt.UserRole)
                    job_id = job_data.get("id")
                    job_status = job_data.get("status")
                    resource_url = job_data.get("resource_url")

                    if job_status == "end" and resource_url:
                        downloadable_jobs.append((row, job_id))
                    else:
                        non_downloadable_jobs.append(job_id)

            except Exception as e:
                self.update_status(f"Error processing job from row {row}: {e}", "error")

        # Show warning for non-downloadable jobs
        if non_downloadable_jobs:
            self.update_status(
                f"Warning: Jobs {non_downloadable_jobs} cannot be downloaded (not completed or no resource available).",
                "warning",
            )

        if not downloadable_jobs:
            self.update_status("No downloadable jobs selected.", "warning")
            return

        self.update_status(
            f"Downloading {len(downloadable_jobs)} selected job(s)...", "info"
        )

        for row, job_id in downloadable_jobs:
            try:
                # Download the job resource
                self.download_job_resource(job_id)
            except Exception as e:
                self.update_status(f"Error downloading job {job_id}: {e}", "error")

    def download_job_resource(self, job_id):
        """Download a specific job resource and load it into QGIS"""
        try:
            # First, get the job details to retrieve the datatype_id
            job_url = f"{self.api_base_url}/jobs/{job_id}"
            headers = {"Authorization": f"Bearer {self.access_token}"}

            job_response = requests.get(job_url, headers=headers)
            job_response.raise_for_status()
            job_data = job_response.json()

            # Extract datatype_id from the job data
            datatype_id = job_data.get("body", {}).get("datatype_id", None)

            # Use the same download logic as in MainWorker
            retrieve_url = f"{self.api_base_url}/retrieve/{job_id}"

            self.update_status(f"Downloading job {job_id}...", "info")

            with requests.get(retrieve_url, headers=headers, stream=True) as response:
                response.raise_for_status()

                # Get filename from Content-Disposition header
                content_disp = response.headers.get("Content-Disposition", "")
                filename = None
                if "filename=" in content_disp:
                    filename = content_disp.split("filename=")[-1].strip('"; ')
                if not filename:
                    filename = f"{job_id}.zip"

                # Save to temporary location
                cache_dir = f"./tmp/{job_id}"
                os.makedirs(cache_dir, exist_ok=True)
                cache_path = os.path.join(cache_dir, filename)

                with open(cache_path, "wb") as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)

                # Load the downloaded file into QGIS with datatype_id
                self.load_layer(cache_path, datatype_id)

        except Exception as e:
            self.update_status(f"Error downloading job {job_id}: {e}", "error")

    def delete_selected_jobs(self):
        """Mock delete functionality for selected jobs"""
        selected_rows = set()
        for item in self.jobsTableWidget.selectedItems():
            selected_rows.add(item.row())

        if not selected_rows:
            self.update_status("No jobs selected for deletion.", "warning")
            return

        # Mock behavior - just show a message
        self.update_status(
            f"Mock: Would delete {len(selected_rows)} selected job(s). This functionality is not yet implemented.",
            "info",
        )

        # In a real implementation, you would:
        # 1. Call the API to delete the jobs
        # 2. Remove the rows from the table
        # 3. Update the jobs list

    def refresh_jobs_table(self):
        """Refreshes the jobs table by re-fetching jobs from the API."""
        if not self.access_token:
            self.update_status("Error: Please login before refreshing jobs.", "error")
            return

        self.update_status("Refreshing jobs table...", "info")

        try:
            # Call the API directly to get jobs
            headers = {"Authorization": f"Bearer {self.access_token}"}
            jobs_url = f"{self.api_base_url}/jobs/"

            response = requests.get(jobs_url, headers=headers)
            response.raise_for_status()

            jobs = response.json()["jobs"]
            self.update_jobs_table(jobs)
            self.update_status(
                f"Successfully refreshed jobs table with {len(jobs)} jobs.", "success"
            )

        except requests.exceptions.RequestException as e:
            self.update_status(f"Failed to fetch jobs: {e}", "error")
        except Exception as e:
            self.update_status(f"Unexpected error refreshing jobs: {e}", "error")

    def move_calendar(self, active):
        """Moves calendar between the "start time" and "end time" line edit fields"""
        if active == "start_date":
            self.calendarSpacer.hide()
        else:
            self.calendarSpacer.show()
        self.active_time = active

    def update_dates(self):
        new_start_time = parse_date(self.startDateLineEdit.text())
        new_end_time = parse_date(self.endDateLineEdit.text())

        if new_start_time is None or new_end_time is None:
            self.update_status("Invalid date format.", "error")
        elif new_start_time and new_end_time and new_start_time > new_end_time:
            self.update_status("Start date must be before end date.", "warning")
        elif new_start_time and datetime.fromisoformat(
            new_start_time
        ) > datetime.now().replace(tzinfo=None):
            self.update_status("Start date must be before the current date.", "warning")
        elif new_end_time and datetime.fromisoformat(
            new_end_time
        ) > datetime.now().replace(tzinfo=None):
            self.update_status("End date must be before the current date.", "warning")
        else:
            self.startDateLineEdit.setText(new_start_time)
            self.endDateLineEdit.setText(new_end_time)

    def add_calendar_date(self):
        """Handles selected calendar date"""
        calendar_time = str(self.calendarWidget.selectedDate().toPyDate())

        if self.active_time == "start_date":
            self.startDateLineEdit.setText(calendar_time)
        else:
            self.endDateLineEdit.setText(calendar_time)

    def login(self, *_):
        """
        Handles user login. Reads username and password from the UI,
        sends them to the API, and if successful, enables the Request and Jobs tabs.
        """
        username = (
            self.usernameLineEdit.text().strip()
            if hasattr(self, "usernameLineEdit")
            else ""
        )
        password = (
            self.passwordLineEdit.text().strip()
            if hasattr(self, "passwordLineEdit")
            else ""
        )

        if not username or not password:
            self.loginInfoLabel.setText("Please enter both username and password.")
            return

        self.loginPushButton.setEnabled(False)
        self.loginInfoLabel.setText("Logging in...")

        try:
            auth_url = f"{self.api_base_url}/auth/login"
            auth_data = {
                "username": username,
                "password": password,
            }
            response = requests.post(auth_url, data=auth_data)
            response.raise_for_status()
            token_data = response.json()
            self.access_token = token_data.get("access_token")
            if not self.access_token:
                self.loginInfoLabel.setText("Login failed: No token received.")
                self.loginPushButton.setEnabled(True)
                return

            # Save credentials for later use
            self.username = username
            self.password = password

            self.loginInfoLabel.setText("Login Successful âœ…")
            # Enable the Request and Jobs tabs
            self.tabWidget.setTabEnabled(1, True)
            self.tabWidget.setTabEnabled(2, True)
            # Optionally, switch to the Request tab automatically
            self.tabWidget.setCurrentIndex(1)

            # Start monitoring jobs
            self.start_jobs_monitoring()

        except Exception as e:
            self.loginInfoLabel.setText(f"Login failed: {e}")
            self.loginPushButton.setEnabled(True)

    def send_request(self):
        """
        Sends a request to the API with the selected parameters.

        This function collects and validates the user inputs, constructs a message containing
        the selected polygon layer's geometry, the chosen pipeline, and the time range. It
        then sends this message to the API.

        The process includes:

        - Validating the selected polygon layer and its features.
        - Constructing a unified geometry from all features in the layer.
        - Converting the geometry to WKT format and loading it as a Shapely polygon.
        - Constructing a message dictionary with the pipeline, geometry, and time range.
        - Publishing the message to the API.

        If any error occurs during this process, it updates the status with an error message.

        :raises Exception: If an error occurs during message sending or connection setup.
        """

        # Check if logged in
        if not self.access_token:
            self.update_status("Error: Please login before making a request.", "error")
            return

        # Retrieve user inputs
        selected_layer = self.mMapLayerComboBox.currentLayer()
        pipeline_text = self.layerTypeComboBox.currentText()
        start_dt = self.startDateLineEdit.text()
        end_dt = self.endDateLineEdit.text()

        # Input validation
        if not isinstance(selected_layer, QgsVectorLayer):
            self.update_status("Error: Please select a valid polygon layer.", "error")
            return

        all_geoms = [feature.geometry() for feature in selected_layer.getFeatures()]
        if not all_geoms:
            self.update_status("Error: The selected layer has no features.", "error")
            return

        unified_qgs_geom = QgsGeometry.unaryUnion(all_geoms)
        if unified_qgs_geom.isEmpty():
            self.update_status(
                "Error: Could not create a valid geometry from the layer.", "error"
            )
            return

        wkt_geometry = unified_qgs_geom.asWkt()
        shapely_polygon = wkt_loads(wkt_geometry)

        if not all([selected_layer]):
            self.update_status("Error: All fields are required to send.", "error")
            return

        # Start Processing
        try:
            self.update_status("Sending request to API...")

            # Use the saved access token for authentication
            headers = {"Authorization": f"Bearer {self.access_token}"}

            # Create job request
            job_url = f"{self.api_base_url}/jobs/create"
            job_data = {
                "datatype_id": self.pipeline_map[pipeline_text],
                "geometry": mapping(shapely_polygon),
                "start_date": start_dt,
                "end_date": end_dt,
            }

            job_response = requests.post(job_url, json=job_data, headers=headers)
            job_response.raise_for_status()

            job_result = job_response.json()
            job_id = job_result["id"]
            self.add_log_separator()
            self.update_status(f"Job created with ID: {job_id}", "info")

            # Start monitoring the job
            self.start_listening(job_id)

        except Exception as e:
            self.update_status(f"Error sending request: {e}", "error")

    def start_listening(self, job_id):
        """Set up the worker and thread to start monitoring the job."""
        if self.thread is not None and self.thread.isRunning():
            self.update_status("Already monitoring a job.", "warning")
            return

        # Create a QThread
        self.thread = QThread()
        # Create a worker
        self.worker = MainWorker(
            api_base_url=self.api_base_url,
            username=self.username,
            password=self.password,
            job_id=job_id,
        )

        # Move worker to the thread
        self.worker.moveToThread(self.thread)

        # Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)

        # Connect the thread's finished signal to our cleanup method
        self.thread.finished.connect(self.cleanup_thread)

        self.worker.layer_ready.connect(self.load_layer)
        self.worker.status_updated.connect(self.update_status)
        self.worker.log_separator.connect(self.add_log_separator)
        self.worker.error.connect(lambda msg: self.update_status(msg, "error"))

        # Start the thread
        self.thread.start()

        # Disable button
        self.requestPushButton.setEnabled(False)
        self.update_status(f"Started monitoring job {job_id}...", "info")

    def load_layer(self, file_path, datatype_id=None):
        """Loads the downloaded file into QGIS. This runs on the main thread."""
        self.update_status(
            f"Loading retrieved layer: {os.path.basename(file_path)}", "info"
        )
        layer_name = os.path.splitext(os.path.basename(file_path))[0]

        # --- HANDLE ZIP ARCHIVES ---
        if file_path.lower().endswith(".zip"):
            self.handle_zip_file(file_path, layer_name, datatype_id)
        # --- HANDLE SINGLE TIF/TIFF FILES ---
        elif file_path.lower().endswith((".tif", ".tiff")):
            self.handle_single_tif(file_path, layer_name, datatype_id)
        # --- HANDLE UNSUPPORTED FILES ---
        else:
            self.update_status(
                f"Warning: File type not supported for auto-loading: {file_path}",
                "warning",
            )

    def handle_single_tif(self, file_path, layer_name, datatype_id=None):
        """Loads a single TIF file as a QGIS layer and applies a style."""
        self.update_status(f"Loading raster layer: {layer_name}", "info")
        layer = QgsRasterLayer(file_path, layer_name)

        if not layer.isValid():
            self.update_status(
                f"Error: Failed to load raster layer {layer_name}", "error"
            )
            return

        # Apply style if datatype_id is available and in the style map
        if datatype_id and datatype_id in self.style_map:
            style_filename = self.style_map[datatype_id]
            style_path = os.path.join(
                os.path.dirname(__file__), self.style_root, style_filename
            )

            if os.path.exists(style_path):
                loaded = layer.loadNamedStyle(style_path)
                layer.triggerRepaint()
                if loaded[0]:
                    self.update_status(f"Applied style from {style_filename}", "info")
                else:
                    self.update_status(
                        f"Applied style from {style_filename} (QGIS returned warning: {loaded[1]})",
                        "info",
                    )
            else:
                self.update_status(
                    f"Warning: Style file not found: {style_path}", "warning"
                )
        else:
            self.update_status(
                "No style applied - datatype_id not available or not in style map.",
                "info",
            )

        QgsProject.instance().addMapLayer(layer)
        self.update_status(f"Successfully loaded {layer_name}", "success")
        self.add_log_separator()

    def handle_zip_file(self, zip_path, group_name, datatype_id=None):
        """
        Unzips an archive and loads all contained .tif files into a new layer group, applying a style to each.
        """
        # Use a temporary directory that is automatically cleaned up

        extract_dir = tempfile.mkdtemp(prefix="qgis_ermes_")
        self.temp_dirs_to_clean.append(extract_dir)

        try:
            # Extract the zip file
            with zipfile.ZipFile(zip_path, "r") as zip_ref:
                zip_ref.extractall(extract_dir)
            try:
                os.remove(zip_path)
            except OSError as e:
                self.update_status(
                    f"Warning: Could not remove original zip file {zip_path}: {e}",
                    "warning",
                )
        except zipfile.BadZipFile:
            self.update_status(
                f"Error: '{os.path.basename(zip_path)}' is not a valid zip file.",
                "error",
            )
            return
        except Exception as e:
            self.update_status(f"Error extracting zip file: {e}", "error")
            return

        # Scan the extracted directory for .tif files
        tiff_files = []
        for root_dir, _, files in os.walk(extract_dir):
            for file in files:
                if file.lower().endswith((".tif", ".tiff")):
                    tiff_files.append(os.path.join(root_dir, file))

        if not tiff_files:
            self.update_status(
                f"No .tif files were found inside '{os.path.basename(zip_path)}'.",
                "warning",
            )
            return

        # Get the project instance and the root of the layer tree
        project = QgsProject.instance()
        root = project.layerTreeRoot()

        # Create a new group in the layer tree. The group_name comes from layer_name.
        group = root.addGroup(group_name)

        # Get style path if datatype_id is available and in the style map
        style_path = None
        if datatype_id and datatype_id in self.style_map:
            style_filename = self.style_map[datatype_id]
            style_path = os.path.join(
                os.path.dirname(__file__), self.style_root, style_filename
            )

        loaded_count = 0
        for tiff_path in tiff_files:
            # Use the tif's own filename as the layer name
            individual_layer_name = os.path.splitext(os.path.basename(tiff_path))[0]

            layer = QgsRasterLayer(tiff_path, individual_layer_name)
            if not layer.isValid():
                self.update_status(
                    f"Skipping invalid raster: {individual_layer_name}", "warning"
                )
                continue

            # Apply style if available
            if style_path and os.path.exists(style_path):
                loaded = layer.loadNamedStyle(style_path)
                if loaded[0]:
                    layer.triggerRepaint()
                    self.update_status(
                        f"Applied style to {individual_layer_name} from {os.path.basename(style_path)}",
                        "info",
                    )
                else:
                    pass
            else:
                if datatype_id and datatype_id in self.style_map:
                    self.update_status(
                        f"Style file not found for {individual_layer_name}, loading without style.",
                        "warning",
                    )
                else:
                    self.update_status(
                        f"No style applied to {individual_layer_name} - datatype_id not available or not in style map.",
                        "info",
                    )

            # Add the layer to the project's internal registry, but NOT to the legend yet (False).
            # This prevents it from appearing at the top level.
            project.addMapLayer(layer, False)

            # Now, add the layer to our newly created group.
            group.addLayer(layer)
            loaded_count += 1

        self.update_status(
            f"Successfully loaded {loaded_count} layer(s) into group '{group_name}'.",
            "success",
        )
        self.add_log_separator()

    def add_log_separator(self):
        """Adds a separator to the log."""
        self.status_messages.append("========================================")
        try:
            if self.textLogger is not None:
                self.textLogger.setText("\n".join(self.status_messages))

                # Auto-scroll to the bottom
                scrollbar = self.textLogger.verticalScrollBar()
                scrollbar.setValue(scrollbar.maximum())
        except:
            # textLogger doesn't exist, just continue without updating it
            pass

    def update_status(self, message, level="info"):
        """Updates the status label and logs to QGIS log."""
        # Add timestamp and format the message
        timestamp = datetime.now().strftime("%H:%M:%S")
        formatted_message = f"{level.upper()}: {message}"
        formatted_message_with_timestamp = f"[{timestamp}] {formatted_message}"

        # Check for duplicate: identical level and message (ignoring timestamp)

        if formatted_message not in self._cached_messages:
            self._cached_messages.append(formatted_message)
            self.status_messages.append(formatted_message_with_timestamp)

            # Only update the textLogger if it exists
            try:
                if self.textLogger is not None:
                    self.textLogger.setText("\n".join(self.status_messages))

                    # Auto-scroll to the bottom
                    scrollbar = self.textLogger.verticalScrollBar()
                    scrollbar.setValue(scrollbar.maximum())
            except:
                # textLogger doesn't exist, just continue without updating it
                pass

        log_level = Qgis.Info
        if level == "error":
            log_level = Qgis.Critical
        elif level == "warning":
            log_level = Qgis.Warning
        elif level == "success":
            log_level = Qgis.Success

        QgsMessageLog.logMessage(message, "Ermes_API", level=log_level)

    def closeEvent(self, event):
        """Ensure the thread is stopped when the dialog is closed."""
        try:
            if self.thread and self.thread.isRunning():
                self.worker.stop()
                self.thread.quit()
                self.thread.wait()  # Wait for the thread to finish

            # Stop jobs monitoring
            if self.jobs_thread and self.jobs_thread.isRunning():
                self.jobs_worker.stop()
                self.jobs_thread.quit()
                self.jobs_thread.wait()
        except:
            pass

        event.accept()

    def cleanup_thread(self):
        """
        Cleans up thread and worker references after the thread has finished.
        This slot is connected to the thread's finished signal.
        """
        # Re-enable the button so the user can start another job
        self.requestPushButton.setEnabled(True)

        # Set the Python references to None
        self.thread = None
        self.worker = None

    def cleanup_temp_dirs(self):
        """
        This function is called when QGIS is about to quit.
        It safely removes all temporary directories created during the session.
        """
        try:
            self.update_status(
                f"Cleaning up {len(self.temp_dirs_to_clean)} temporary directories...",
                "info",
            )
            for dir_path in self.temp_dirs_to_clean:
                try:
                    # shutil.rmtree can remove a directory and all its contents
                    shutil.rmtree(dir_path)
                except Exception as e:
                    # Log an error but don't prevent QGIS from closing
                    print(f"Could not remove temporary directory {dir_path}: {e}")
                    self.update_status(
                        f"Warning: Could not remove temp dir {dir_path}", "warning"
                    )

            self.temp_dirs_to_clean.clear()
        except Exception as e:
            # Log an error but don't prevent QGIS from closing
            print(f"Could not remove temporary directory {dir_path}: {e}")
            self.update_status(
                f"Warning: Could not remove temp dir {dir_path}", "warning"
            )

        self.temp_dirs_to_clean.clear()

    def validate_form(self):
        """Validates the form and enables/disables the request button accordingly"""
        # Check if all required fields are filled
        start_date = self.startDateLineEdit.text().strip()
        end_date = self.endDateLineEdit.text().strip()
        selected_layer = self.mMapLayerComboBox.currentLayer()

        # Basic validation: all fields must be present
        if not start_date or not end_date or not selected_layer:
            self.requestPushButton.setEnabled(False)
            return

        # Validate date format and range
        try:
            start_parsed = parse_date(start_date)
            end_parsed = parse_date(end_date)

            if start_parsed is None or end_parsed is None:
                self.requestPushButton.setEnabled(False)
                return

            if start_parsed and end_parsed and start_parsed > end_parsed:
                self.requestPushButton.setEnabled(False)
                return

        except Exception:
            self.requestPushButton.setEnabled(False)
            return

        # Validate that selected layer is a valid polygon layer with features
        if not isinstance(selected_layer, QgsVectorLayer):
            self.requestPushButton.setEnabled(False)
            return

        if selected_layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            self.requestPushButton.setEnabled(False)
            return

        # Check if layer has features
        feature_count = selected_layer.featureCount()
        if feature_count == 0:
            self.requestPushButton.setEnabled(False)
            return

        # All validations passed, enable the button
        self.requestPushButton.setEnabled(True)
